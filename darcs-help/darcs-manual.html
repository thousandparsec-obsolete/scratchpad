<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Darcs 1.0.6pre1 (unknown)
Darcs
</TITLE>
<META NAME="description" CONTENT="Darcs 1.0.6pre1 (unknown)
Darcs
">
<META NAME="keywords" CONTENT="bigpage">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="bigpage.css">

</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<IMG WIDTH="22" HEIGHT="22" title="Next"  ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="./nx_grp_g.png"> 
<IMG WIDTH="22" HEIGHT="22" title="Up"  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./up_g.png"> 
<IMG WIDTH="22" HEIGHT="22" title="Previous"  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./prev_g.png">   
<BR>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<P>

<P>
<H1 ALIGN="CENTER">
    Darcs 1.0.6pre1 (unknown)
<BR><BIG CLASS="XLARGE"><I>Darcs</I></BIG>
</H1>
<DIV CLASS="author_info">

<P ALIGN="CENTER"><STRONG>David Roundy
</STRONG></P>
</DIV>

<P>
<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html139"
  HREF="bigpage.html#SECTION00200000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html140"
  HREF="bigpage.html#SECTION00210000000000000000">Features</A>
<LI><A NAME="tex2html141"
  HREF="bigpage.html#SECTION00220000000000000000">Switching from CVS</A>
<LI><A NAME="tex2html142"
  HREF="bigpage.html#SECTION00230000000000000000">Switching from arch</A>
</UL>
<BR>
<LI><A NAME="tex2html143"
  HREF="bigpage.html#SECTION00300000000000000000">Building darcs</A>
<UL>
<LI><A NAME="tex2html144"
  HREF="bigpage.html#SECTION00310000000000000000">Prerequisites</A>
<LI><A NAME="tex2html145"
  HREF="bigpage.html#SECTION00320000000000000000">Building on Mac&nbsp;OS&nbsp;X</A>
<LI><A NAME="tex2html146"
  HREF="bigpage.html#SECTION00330000000000000000">Building on Microsoft Windows</A>
<LI><A NAME="tex2html147"
  HREF="bigpage.html#SECTION00340000000000000000">Building from tarball</A>
<LI><A NAME="tex2html148"
  HREF="bigpage.html#SECTION00350000000000000000">Building darcs from the repository</A>
<LI><A NAME="tex2html149"
  HREF="bigpage.html#SECTION00360000000000000000">Building darcs with git</A>
<LI><A NAME="tex2html150"
  HREF="bigpage.html#SECTION00370000000000000000">Submitting patches to darcs</A>
</UL>
<BR>
<LI><A NAME="tex2html151"
  HREF="bigpage.html#SECTION00400000000000000000">Getting started</A>
<UL>
<LI><A NAME="tex2html152"
  HREF="bigpage.html#SECTION00410000000000000000">Creating your repository</A>
<LI><A NAME="tex2html153"
  HREF="bigpage.html#SECTION00420000000000000000">Making changes</A>
<LI><A NAME="tex2html154"
  HREF="bigpage.html#SECTION00430000000000000000">Making your repository visible to others</A>
<LI><A NAME="tex2html155"
  HREF="bigpage.html#SECTION00440000000000000000">Getting changes made to another repository</A>
<LI><A NAME="tex2html156"
  HREF="bigpage.html#SECTION00450000000000000000">Moving patches from one repo to another</A>
<UL>
<LI><A NAME="tex2html157"
  HREF="bigpage.html#SECTION00451000000000000000">All pulls</A>
<LI><A NAME="tex2html158"
  HREF="bigpage.html#SECTION00452000000000000000">Send and apply manually</A>
<LI><A NAME="tex2html159"
  HREF="bigpage.html#SECTION00453000000000000000">Push</A>
<LI><A NAME="tex2html160"
  HREF="bigpage.html#SECTION00454000000000000000">Push --apply-as</A>
<LI><A NAME="tex2html161"
  HREF="bigpage.html#SECTION00455000000000000000">Sending signed patches by email</A>
</UL>
<LI><A NAME="tex2html162"
  HREF="bigpage.html#SECTION00460000000000000000">Reducing disk space usage</A>
<UL>
<LI><A NAME="tex2html163"
  HREF="bigpage.html#SECTION00461000000000000000">Linking between repositories</A>
<LI><A NAME="tex2html164"
  HREF="bigpage.html#SECTION00462000000000000000">Alternate formats for the pristine tree</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html165"
  HREF="bigpage.html#SECTION00500000000000000000">Configuring darcs</A>
<UL>
<LI><A NAME="tex2html166"
  HREF="bigpage.html#SECTION00510000000000000000">prefs</A>
<LI><A NAME="tex2html167"
  HREF="bigpage.html#SECTION00520000000000000000">Environment variables</A>
<LI><A NAME="tex2html168"
  HREF="bigpage.html#SECTION00530000000000000000">Highlighted output</A>
<LI><A NAME="tex2html169"
  HREF="bigpage.html#SECTION00540000000000000000">Character escaping and non-ASCII character encodings</A>
</UL>
<BR>
<LI><A NAME="tex2html170"
  HREF="bigpage.html#SECTION00600000000000000000">Best practices</A>
<UL>
<LI><A NAME="tex2html171"
  HREF="bigpage.html#SECTION00610000000000000000">Introduction</A>
<LI><A NAME="tex2html172"
  HREF="bigpage.html#SECTION00620000000000000000">Creating patches</A>
<UL>
<LI><A NAME="tex2html173"
  HREF="bigpage.html#SECTION00621000000000000000">Changes</A>
<LI><A NAME="tex2html174"
  HREF="bigpage.html#SECTION00622000000000000000">Keeping or discarding changes</A>
<LI><A NAME="tex2html175"
  HREF="bigpage.html#SECTION00623000000000000000">Unrecording changes</A>
<LI><A NAME="tex2html176"
  HREF="bigpage.html#SECTION00624000000000000000">Special patches and pending</A>
</UL>
<LI><A NAME="tex2html177"
  HREF="bigpage.html#SECTION00630000000000000000">Using patches</A>
<UL>
<LI><A NAME="tex2html178"
  HREF="bigpage.html#SECTION00631000000000000000">Dependencies</A>
<LI><A NAME="tex2html179"
  HREF="bigpage.html#SECTION00632000000000000000">Branches: just normal repositories</A>
<LI><A NAME="tex2html180"
  HREF="bigpage.html#SECTION00633000000000000000">Moving patches around--no versions</A>
<LI><A NAME="tex2html181"
  HREF="bigpage.html#SECTION00634000000000000000">Tags--versions</A>
<LI><A NAME="tex2html182"
  HREF="bigpage.html#SECTION00635000000000000000">Conflicts</A>
<LI><A NAME="tex2html183"
  HREF="bigpage.html#SECTION00636000000000000000">Resolving conflicts</A>
</UL>
<LI><A NAME="tex2html184"
  HREF="bigpage.html#SECTION00640000000000000000">Distributed development with one primary developer</A>
<LI><A NAME="tex2html185"
  HREF="bigpage.html#SECTION00650000000000000000">Development by a small group of developers in one office</A>
</UL>
<BR>
<LI><A NAME="tex2html186"
  HREF="bigpage.html#SECTION00700000000000000000">Darcs commands</A>
<UL>
<LI><A NAME="tex2html187"
  HREF="bigpage.html#SECTION00710000000000000000">Common options to darcs commands</A>
<LI><A NAME="tex2html188"
  HREF="bigpage.html#SECTION00720000000000000000">Options apart from darcs commands</A>
<LI><A NAME="tex2html189"
  HREF="bigpage.html#SECTION00730000000000000000">Creating repositories</A>
<UL>
<LI><A NAME="tex2html190"
  HREF="bigpage.html#SECTION00731000000000000000">darcs initialize</A>
<LI><A NAME="tex2html191"
  HREF="bigpage.html#SECTION00732000000000000000">darcs get</A>
<LI><A NAME="tex2html192"
  HREF="bigpage.html#SECTION00733000000000000000">darcs put</A>
</UL>
<LI><A NAME="tex2html193"
  HREF="bigpage.html#SECTION00740000000000000000">Modifying the contents of a repo</A>
<UL>
<LI><A NAME="tex2html194"
  HREF="bigpage.html#SECTION00741000000000000000">darcs add</A>
<LI><A NAME="tex2html195"
  HREF="bigpage.html#SECTION00742000000000000000">darcs remove</A>
<LI><A NAME="tex2html196"
  HREF="bigpage.html#SECTION00743000000000000000">darcs mv</A>
<LI><A NAME="tex2html197"
  HREF="bigpage.html#SECTION00744000000000000000">darcs replace</A>
</UL>
<LI><A NAME="tex2html198"
  HREF="bigpage.html#SECTION00750000000000000000">Working with changes</A>
<UL>
<LI><A NAME="tex2html199"
  HREF="bigpage.html#SECTION00751000000000000000">darcs record</A>
<LI><A NAME="tex2html200"
  HREF="bigpage.html#SECTION00752000000000000000">darcs pull</A>
<LI><A NAME="tex2html201"
  HREF="bigpage.html#SECTION00753000000000000000">darcs push</A>
<LI><A NAME="tex2html202"
  HREF="bigpage.html#SECTION00754000000000000000">darcs send</A>
<LI><A NAME="tex2html203"
  HREF="bigpage.html#SECTION00755000000000000000">darcs apply</A>
</UL>
<LI><A NAME="tex2html204"
  HREF="bigpage.html#SECTION00760000000000000000">Seeing what you've done</A>
<UL>
<LI><A NAME="tex2html205"
  HREF="bigpage.html#SECTION00761000000000000000">darcs whatsnew</A>
<LI><A NAME="tex2html206"
  HREF="bigpage.html#SECTION00762000000000000000">darcs changes</A>
<LI><A NAME="tex2html207"
  HREF="bigpage.html#SECTION00763000000000000000">darcs query manifest</A>
</UL>
<LI><A NAME="tex2html208"
  HREF="bigpage.html#SECTION00770000000000000000">More advanced commands</A>
<UL>
<LI><A NAME="tex2html209"
  HREF="bigpage.html#SECTION00771000000000000000">darcs tag</A>
<LI><A NAME="tex2html210"
  HREF="bigpage.html#SECTION00772000000000000000">darcs setpref</A>
<LI><A NAME="tex2html211"
  HREF="bigpage.html#SECTION00773000000000000000">darcs check</A>
<LI><A NAME="tex2html212"
  HREF="bigpage.html#SECTION00774000000000000000">darcs optimize</A>
</UL>
<LI><A NAME="tex2html213"
  HREF="bigpage.html#SECTION00780000000000000000">Undoing, redoing and running in circles</A>
<UL>
<LI><A NAME="tex2html214"
  HREF="bigpage.html#SECTION00781000000000000000">darcs amend-record</A>
<LI><A NAME="tex2html215"
  HREF="bigpage.html#SECTION00782000000000000000">darcs rollback</A>
<LI><A NAME="tex2html216"
  HREF="bigpage.html#SECTION00783000000000000000">darcs unrecord</A>
<LI><A NAME="tex2html217"
  HREF="bigpage.html#SECTION00784000000000000000">darcs unpull</A>
<LI><A NAME="tex2html218"
  HREF="bigpage.html#SECTION00785000000000000000">darcs obliterate</A>
<LI><A NAME="tex2html219"
  HREF="bigpage.html#SECTION00786000000000000000">darcs revert</A>
<LI><A NAME="tex2html220"
  HREF="bigpage.html#SECTION00787000000000000000">darcs unrevert</A>
</UL>
<LI><A NAME="tex2html221"
  HREF="bigpage.html#SECTION00790000000000000000">Advanced examination of the repository</A>
<UL>
<LI><A NAME="tex2html222"
  HREF="bigpage.html#SECTION00791000000000000000">darcs diff</A>
<LI><A NAME="tex2html223"
  HREF="bigpage.html#SECTION00792000000000000000">darcs annotate</A>
<LI><A NAME="tex2html224"
  HREF="bigpage.html#SECTION00793000000000000000">darcs query manifest</A>
</UL>
<LI><A NAME="tex2html225"
  HREF="bigpage.html#SECTION007100000000000000000">Rarely needed and obscure commands</A>
<UL>
<LI><A NAME="tex2html226"
  HREF="bigpage.html#SECTION007101000000000000000">darcs resolve</A>
<LI><A NAME="tex2html227"
  HREF="bigpage.html#SECTION007102000000000000000">darcs dist</A>
<LI><A NAME="tex2html228"
  HREF="bigpage.html#SECTION007103000000000000000">darcs trackdown</A>
<LI><A NAME="tex2html229"
  HREF="bigpage.html#SECTION007104000000000000000">darcs repair</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html230"
  HREF="bigpage.html#SECTION00800000000000000000">Theory of patches</A>
<UL>
<LI><A NAME="tex2html231"
  HREF="bigpage.html#SECTION00810000000000000000">Background</A>
<LI><A NAME="tex2html232"
  HREF="bigpage.html#SECTION00820000000000000000">Introduction</A>
<LI><A NAME="tex2html233"
  HREF="bigpage.html#SECTION00830000000000000000">Applying patches</A>
<UL>
<LI><A NAME="tex2html234"
  HREF="bigpage.html#SECTION00831000000000000000">Hunk patches</A>
<LI><A NAME="tex2html235"
  HREF="bigpage.html#SECTION00832000000000000000">Token replace patches</A>
</UL>
<LI><A NAME="tex2html236"
  HREF="bigpage.html#SECTION00840000000000000000">Patch relationships</A>
<LI><A NAME="tex2html237"
  HREF="bigpage.html#SECTION00850000000000000000">Commuting patches</A>
<UL>
<LI><A NAME="tex2html238"
  HREF="bigpage.html#SECTION00851000000000000000">Composite patches</A>
<LI><A NAME="tex2html239"
  HREF="bigpage.html#SECTION00852000000000000000">How merges are actually performed</A>
<LI><A NAME="tex2html240"
  HREF="bigpage.html#SECTION00853000000000000000">File patches</A>
<LI><A NAME="tex2html241"
  HREF="bigpage.html#SECTION00854000000000000000">Hunks</A>
</UL>
<LI><A NAME="tex2html242"
  HREF="bigpage.html#SECTION00860000000000000000">Conflicts</A>
<LI><A NAME="tex2html243"
  HREF="bigpage.html#SECTION00870000000000000000">Patch string formatting</A>
</UL>
<BR>
<LI><A NAME="tex2html244"
  HREF="bigpage.html#SECTION00900000000000000000">DarcsRepo format</A>
<LI><A NAME="tex2html245"
  HREF="bigpage.html#SECTION001000000000000000000">The GNU General Public License</A>
<UL>
<LI><A NAME="tex2html246"
  HREF="bigpage.html#SECTION001030000000000000000">Appendix: How to Apply These Terms to Your New Programs</A>
</UL></UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00200000000000000000">
Introduction</A>
</H1>

<P>
Darcs is a revision control system, along the lines of CVS or arch.  That
means that it keeps track of various revisions and branches of your
project, allows for changes to propagate from one branch to another.  Darcs
is intended to be an ``advanced'' revision control system.  Darcs has two
particularly distinctive features which differ from other revision control
systems: 1) each copy of the source is a fully functional branch, and 2)
underlying darcs is a consistent and powerful theory of patches.

<P>

<H4><A NAME="SECTION00200010000000000000">
Every source tree a branch</A>
</H4>
The primary simplifying notion of darcs is that <SPAN  CLASS="textit">every</SPAN> copy of your
source code is a full repository. This is dramatically different from CVS,
in which the normal usage is for there to be one central repository from
which source code will be checked out. It is closer to the notion of arch,
since the `normal' use of arch is for each developer to create his own
repository. However, darcs makes it even easier, since simply checking out
the code is all it takes to create a new repository. This has several
advantages, since you can harness the full power of darcs in any scratch
copy of your code, without committing your possibly destabilizing changes to
a central repository.

<P>

<H4><A NAME="SECTION00200020000000000000">
Theory of patches</A>
</H4>
The development of a simplified theory of patches is what originally
motivated me to create darcs. This patch formalism means that darcs patches
have a set of properties, which make possible manipulations that couldn't be
done in other revision control systems. First, every patch is invertible.
Secondly, sequential patches (i.e. patches that are created in sequence, one
after the other) can be reordered, although this reordering can fail, which
means the second patch is dependent on the first. Thirdly, patches which are
in parallel (i.e. both patches were created by modifying identical trees)
can be merged, and the result of a set of merges is independent of the order
in which the merges are performed. This last property is critical to darcs'
philosophy, as it means that a particular version of a source tree is fully
defined by the list of patches that are in it, i.e. there is no issue
regarding the order in which merges are performed. For a more thorough
discussion of darcs' theory of patches, see Appendix&nbsp;<A HREF="#Patch"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.

<P>

<H4><A NAME="SECTION00200030000000000000">
A simple advanced tool</A>
</H4>
Besides being ``advanced'' as discussed above, darcs is actually also quite
simple. Versioning tools can be seen as three layers. At the foundation is
the ability to manipulate changes. On top of that must be placed some kind
of database system to keep track of the changes. Finally, at the very top is
some sort of distribution system for getting changes from one place to
another.

<P>
Really, only the first of these three layers is of particular interest to
me, so the other two are done as simply as possible.  At the database
layer, darcs just has an ordered list of patches along with the patches
themselves, each stored as an individual file.  Darcs' distribution system
is strongly inspired by that of arch.  Like arch, darcs uses a dumb server,
typically apache or just a local or network file system when pulling
patches.  darcs has built-in support for using <code>ssh</code> to write to a remote file
system. A darcs executable is called on the remote system to apply the patches.
Arbitrary other transport protocols are supported, through an environment
variable describing a command that will run darcs on the remote system.
See the documentation for DARCS_APPLY_FOO in Chapter&nbsp;<A HREF="#configuring"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>
for details.

<P>
The recommended method is to send patches through gpg-signed email
messages, which has the advantage of being mostly asynchronous.

<P>

<H4><A NAME="SECTION00200040000000000000">
Keeping track of changes rather than versions</A>
</H4>

<P>
In the last paragraph, I explained revision control systems in terms of
three layers.  One can also look at them as having two distinct uses.  One
is to provide a history of previous versions.  The other is to keep track
of changes that are made to the repository, and to allow these changes to
be merged and moved from one repository to another.  These two uses are
distinct, and almost orthogonal, in the sense that a tool can support one
of the two uses optimally while providing no support for the other.  Darcs
is not intended to maintain a history of versions, although it is possible
to kludge together such a revision history, either by making each new patch
depend on all previous patches, or by tagging regularly.  In a sense, this
is what the tag feature is for, but the intention is that tagging will be
used only to mark particularly notable versions (e.g. released versions, or
perhaps versions that pass a time consuming test suite).

<P>
Other revision control systems are centered upon the job of keeping track
of a history of versions, with the ability to merge changes being added as
it was seen that this would be desirable.  But the fundamental object
remained the versions themselves.

<P>
In such a system, a patch (I am using patch here to mean an encapsulated
set of changes) is uniquely determined by two trees.  Merging changes that
are in two trees consists of finding a common parent tree, computing the
diffs of each tree with their parent, and then cleverly combining those two
diffs and applying the combined diff to the parent tree, possibly at some
point in the process allowing human intervention, to allow for fixing up
problems in the merge such as conflicts.

<P>
In the world of darcs, the source tree is <SPAN  CLASS="textit">not</SPAN> the fundamental
object, but rather the patch is the fundamental object.  Rather than a
patch being defined in terms of the difference between two trees, a tree is
defined as the result of applying a given set of patches to an empty tree.
Moreover, these patches may be reordered (unless there are dependencies
between the patches involved) without changing the tree.  As a result,
there is no need to find a common parent when performing a merge.  Or, if
you like, their common parent is defined by the set of common patches, and
may not correspond to any version in the version history.

<P>
One useful consequence of darcs' patch-oriented philosophy is that since a
patch need not be uniquely defined by a pair of trees (old and new), we can
have several ways of representing the same change, which differ only in how
they commute and what the result of merging them is.  Of course, creating
such a patch will require some sort of user input.  This is a Good Thing,
since the user <SPAN  CLASS="textit">creating</SPAN> the patch should be the one forced to think
about what he really wants to change, rather than the users merging the
patch.  An example of this is the token replace patch (See
Section&nbsp;<A HREF="#token_replace"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>).  This feature makes it possible to create a
patch, for example, which changes every instance of the variable
``stupidly_named_var'' to ``better_var_name'', while leaving
``other_stupidly_named_var'' untouched.  When this patch is merged with
any other patch involving the ``stupidly_named_var'', that instance will
also be modified to ``better_var_name''.  This is in contrast to a more
conventional merging method which would not only fail to change new
instances of the variable, but would also involve conflicts when merging
with any patch that modifies lines containing the variable.  By more using
additional information about the programmer's intent, darcs is thus able to
make the process of changing a variable name the trivial task that it
really is, which is really just a trivial search and replace, modulo
tokenizing the code appropriately.

<P>
The patch formalism discussed in Appendix&nbsp;<A HREF="#Patch"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A> is what makes darcs'
approach possible.  In order for a tree to consist of a set of patches,
there must be a deterministic merge of any set of patches, regardless of the
order in which they must be merged.  This requires that one be able to
reorder patches.  While I don't know that the patches are required to be
invertible as well, my implementation certainly requires invertibility.  In
particular, invertibility is required to make use of
Theorem&nbsp;<A HREF="#merge_thm"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>, which is used extensively in the manipulation of
merges.

<P>

<H1><A NAME="SECTION00210000000000000000">
Features</A>
</H1>

<P>

<H4><A NAME="SECTION00210010000000000000">
Record changes locally</A>
</H4>
In darcs, the equivalent of a cvs ``commit'' is called record, because it
doesn't put the change into any remote or centralized repository.  Changes
are always recorded locally, meaning no net access is required in order to
work on your project and record changes as you make them.  Moreover, this
means that there is no need for a separate ``disconnected operation'' mode.

<P>

<H4><A NAME="SECTION00210020000000000000">
Interactive records</A>
</H4>
You can choose to perform an interactive record, in which case darcs will
prompt you for each change you have made and ask if you wish to record it.
Of course, you can tell darcs to record all the changes in a given file, or
to skip all the changes in a given file, or go back to a previous change,
or whatever.  There is also an experimental graphical interface, which
allows you to view and choose changes even more easily, and in whichever
order you like.

<P>

<H4><A NAME="SECTION00210030000000000000">
Unrecord local changes</A>
</H4>
As a corollary to the ``local'' nature of the record operation, if a change
hasn't yet been published to the world--that is, if the local repository
isn't accessible by others--you can safely unrecord a change (even if it
wasn't the most recently recorded change) and then re-record it
differently, for example if you forgot to add a file, introduced a bug or
realized that what you recorded as a single change was really two separate
changes.

<P>

<H4><A NAME="SECTION00210040000000000000">
Interactive everything else</A>
</H4>
Most darcs commands support an interactive interface.  The ``revert''
command, for example, which undoes unrecorded changes has the same
interface as record, so you can easily revert just a single change.  Pull,
push, send and apply all allow you to view and interactively select which
changes you wish to pull, push, send or apply.

<P>

<H4><A NAME="SECTION00210050000000000000">
Test suites</A>
</H4>
Darcs has support for integrating a test suite with a repository.  If you
choose to use this, you can define a test command (e.g. ``make check'') and
have darcs run that command on a clean copy of the project either prior to
recording a change or prior to applying changes--and to reject changes
that cause the test to fail.

<P>

<H4><A NAME="SECTION00210060000000000000">
Any old server</A>
</H4>
Darcs does not require a specialized server in order to make a repository
available for read access.  You can use http, ftp, or even just a plain old
ssh server to access your darcs repository.

<P>

<H4><A NAME="SECTION00210070000000000000">
You decide write permissions</A>
</H4>
Darcs doesn't try to manage write access.  That's your business.  Supported
push methods include direct ssh access (if you're willing to <SPAN  CLASS="textit">give</SPAN>
direct ssh access away), using sudo to allow users who already have shell
access to only apply changes to the repository, or verification of
gpg-signed changes sent by email against a list of allowed keys.  In
addition, there is good support for submission of patches by email that
are not automatically applied, but can easily be applied with a shell escape
from a mail reader (this is how I deal with contributions to darcs).

<P>

<H4><A NAME="SECTION00210080000000000000">
Symmetric repositories</A>
</H4>
Every darcs repository is created equal (well, with the exception of a
``partial'' repository, which doesn't contain a full history...), and every
working directory has an associated repository.  As a result, there is a
symmetry between ``uploading'' and ``downloading'' changes--you can use
the same commands (push or pull) for either purpose.

<P>

<H4><A NAME="SECTION00210090000000000000">
CGI script</A>
</H4>
Darcs has a CGI script that allows browsing of the repositories.

<P>

<H4><A NAME="SECTION002100100000000000000">
Portable</A>
</H4>
Darcs runs on UNIX (or UNIX-like) systems (which includes Mac&nbsp;OS&nbsp;X) as well
as on Microsoft Windows.

<P>

<H4><A NAME="SECTION002100110000000000000">
File and directory moves</A>
</H4>
Renames or moves of files and directories, of course are handled properly,
so when you rename a file or move it to a different directory, its history
is unbroken, and merges with repositories that don't have the file renamed
will work as expected.

<P>

<H4><A NAME="SECTION002100120000000000000">
Token replace</A>
</H4>
You can use the ``darcs replace'' command to modify all occurrences of a
particular token (defined by a configurable set of characters that are
allowed in ``tokens'') in a file.  This has the advantage that merges with
changes that introduce new copies of the old token will have the effect of
changing it to the new token--which comes in handy when changing a
variable or function name that is used throughout a project.

<P>

<H4><A NAME="SECTION002100130000000000000">
Configurable defaults</A>
</H4>
You can easily configure the default flags passed to any command on either
a per-repository or a per-user basis or a combination thereof.

<P>

<H1><A NAME="SECTION00220000000000000000">
Switching from CVS</A>
</H1>

<P>
Darcs is refreshingly different from CVS.

<P>
CVS keeps version controlled data in a central repository, and
requires that users check out a working directory whenever they wish
to access the version-controlled sources.  In order to modify the
central repository, a user needs to have write access to the central
repository; if he doesn't, CVS merely becomes a tool to get the latest
sources.

<P>
In darcs there is no distinction between working directories and
repositories.  In order to work on a project, a user makes a local
copy of the repository he wants to work in; he may then harness the
full power of version control locally.  In order to distribute his
changes, a user who has write access can <SPAN  CLASS="textit">push</SPAN> them to the
remote repository; one who doesn't can simply send them by e-mail in a
format that makes them easy to apply on the remote system.

<P>

<H4><A NAME="SECTION00220010000000000000">
Darcs commands for CVS users</A>
</H4>
Because of the different models used by cvs and darcs, it is
difficult to provide a complete equivalence between cvs and darcs.
A rough correspondence for the everyday commands follows:
<BR><DL>
<DT><STRONG><TT>cvs checkout</TT> </STRONG></DT>
<DD><TT>darcs get</TT>
</DD>
<DT><STRONG><TT>cvs update</TT> </STRONG></DT>
<DD><TT>darcs pull</TT>
</DD>
<DT><STRONG><TT>cvs -n update</TT> </STRONG></DT>
<DD><TT>darcs pull <code>--dry-run</code></TT>
      (summarize remote changes)
</DD>
<DT><STRONG><TT>cvs -n update</TT> </STRONG></DT>
<DD><TT>darcs whatsnew <code>--summary</code></TT>
      (summarize local changes)
</DD>
<DT><STRONG><TT>cvs -n update | grep '?'</TT> </STRONG></DT>
<DD><TT>darcs whatsnew -ls | grep <code>^a</code> </TT>
      (list potential files to add)
</DD>
<DT><STRONG><TT>rm foo.txt; cvs update foo.txt</TT> </STRONG></DT>
<DD><TT>darcs revert foo.txt</TT>
      (revert to foo.txt from repo)
</DD>
<DT><STRONG><TT>cvs diff</TT> </STRONG></DT>
<DD><TT>darcs whatsnew</TT>
      (if checking local changes)
</DD>
<DT><STRONG><TT>cvs diff</TT> </STRONG></DT>
<DD><TT>darcs diff</TT>
      (if checking recorded changes)
</DD>
<DT><STRONG><TT>cvs commit</TT> </STRONG></DT>
<DD><TT>darcs record</TT>
      (if committing locally)
</DD>
<DT><STRONG><TT>cvs commit</TT> </STRONG></DT>
<DD><TT>darcs tag</TT>
      (if marking a version for later use)
</DD>
<DT><STRONG><TT>cvs commit</TT> </STRONG></DT>
<DD><TT>darcs push</TT> or <TT>darcs send</TT>
      (if committing remotely)
</DD>
<DT><STRONG><TT>cvs diff | mail</TT> </STRONG></DT>
<DD><TT>darcs send</TT>
</DD>
<DT><STRONG><TT>cvs add</TT> </STRONG></DT>
<DD><TT>darcs add</TT>
</DD>
<DT><STRONG><TT>cvs tag -b</TT> </STRONG></DT>
<DD><TT>darcs get</TT>
</DD>
<DT><STRONG><TT>cvs tag</TT> </STRONG></DT>
<DD><TT>darcs tag</TT>
</DD>
</DL>

<P>

<H4><A NAME="SECTION00220020000000000000">
Migrating CVS repositories to darcs</A>
</H4>

<P>
Tools and instructions for migrating CVS repositories to darcs are provided
on the darcs community website: 
<A NAME="tex2html1"
  HREF="http://darcs.net/DarcsWiki/ConvertingFromCvs">http://darcs.net/DarcsWiki/ConvertingFromCvs</A>
<P>

<H1><A NAME="SECTION00230000000000000000">
Switching from arch</A>
</H1>

<P>
Although arch, like darcs, is a distributed system, and the two systems
have many similarities (both require no special server, for example), their
essential organization is very different.

<P>
Like CVS, arch keeps data in two types of data structures:
repositories (called ``archives'') and working directories.  In order
to modify a repository, one must first check out a corresponding
working directory. This requires that users remember a number of
different ways of pushing data around -- <code>tla</code> <code>get</code>,
<code>update</code>, <code>commit</code>, <code>archive-mirror</code> and so on.

<P>
In darcs, on the other hand, there is no distinction between working
directories and repositories, and just checking out your sources
creates a local copy of a repository.  This allows you to harness the
full power of version control in any scratch copy of your sources, and
also means that there are just two ways to push data around:
<code>darcs</code> <code>record</code>, which stores edits into your local
repository, and <code>pull</code>, which moves data between repositories.
(<code>darcs</code> <code>push</code> is merely the opposite of <code>pull</code>;
<code>send</code> and <code>apply</code> are just the two halves of <code>push</code>).

<P>

<H4><A NAME="SECTION00230010000000000000">
Darcs commands for arch users</A>
</H4>

<P>
Because of the different models used by arch and darcs, it is
difficult to provide a complete equivalence between arch and darcs.
A rough correspondence for the everyday commands follows:
<BR><DL>
<DT><STRONG><TT>tla init-tree</TT> </STRONG></DT>
<DD><TT>darcs initialize</TT>
</DD>
<DT><STRONG><TT>tla get</TT> </STRONG></DT>
<DD><TT>darcs get</TT>
</DD>
<DT><STRONG><TT>tla update</TT> </STRONG></DT>
<DD><TT>darcs pull</TT>
</DD>
<DT><STRONG><TT>tla file-diffs f | patch -R </TT> </STRONG></DT>
<DD><TT>darcs revert</TT>
</DD>
<DT><STRONG><TT>tla changes -diffs</TT> </STRONG></DT>
<DD><TT>darcs whatsnew</TT>
</DD>
<DT><STRONG><TT>tla logs</TT> </STRONG></DT>
<DD><TT>darcs changes</TT>
</DD>
<DT><STRONG><TT>tla file-diffs</TT> </STRONG></DT>
<DD><TT>darcs diff -u</TT>
</DD>
<DT><STRONG><TT>tla add</TT> </STRONG></DT>
<DD><TT>darcs add</TT>
</DD>
<DT><STRONG><TT>tla mv</TT> </STRONG></DT>
<DD><TT>darcs mv</TT>
      (not <TT>tla move</TT>)
</DD>
<DT><STRONG><TT>tla commit</TT> </STRONG></DT>
<DD><TT>darcs record</TT>
      (if committing locally)
</DD>
<DT><STRONG><TT>tla commit</TT> </STRONG></DT>
<DD><TT>darcs tag</TT>
      (if marking a version for later use)
</DD>
<DT><STRONG><TT>tla commit</TT> </STRONG></DT>
<DD><TT>darcs push</TT> or <TT>darcs send</TT>
      (if committing remotely)
</DD>
<DT><STRONG><TT>tla archive-mirror</TT> </STRONG></DT>
<DD><TT>darcs pull</TT> or <TT>darcs push</TT>
</DD>
<DT><STRONG><TT>tla tag</TT> </STRONG></DT>
<DD><TT>darcs get</TT>
      (if creating a branch)
</DD>
<DT><STRONG><TT>tla tag</TT> </STRONG></DT>
<DD><TT>darcs tag</TT>
      (if creating a tag).
</DD>
</DL>

<P>

<H4><A NAME="SECTION00230020000000000000">
Migrating arch repositories to darcs</A>
</H4>

<P>
Tools and instructions for migrating arch repositories to darcs are provided
on the darcs community website: 
<A NAME="tex2html2"
  HREF="http://darcs.net/DarcsWiki/ConvertingFromArch">http://darcs.net/DarcsWiki/ConvertingFromArch</A>
<P>

<H1><A NAME="SECTION00300000000000000000">
Building darcs</A>
</H1>

<P>
This chapter should walk you through the steps necessary to build darcs for
yourself.  There are in general two ways to build darcs.  One is for
building released versions from tarballs, and the other is to build the
latest and greatest darcs, from the darcs repo itself.

<P>
Please let me know if you have any problems building darcs, or don't have
problems described in this chapter and think there's something obsolete
here, so I can keep this page up-to-date.

<P>

<H1><A NAME="SECTION00310000000000000000">
Prerequisites</A>
</H1>
To build darcs you will need to have <TT>ghc</TT>, the Glorious Glasgow
Haskell Compiler. You should have at the very minimum version 6.2.

<P>
It is a good idea (but not required) to have a recent version of libcurl
installed.  If not, you will at least need to have either <TT>wget</TT> or
<TT>curl</TT> installed if you want to be able to grab repos remotely over
normal network protocols (ftp or http).  You also might want to have scp
available if you want to grab your repos over ssh...

<P>
To send patches, you will also need to have a working
<code>/usr/sbin/sendmail</code> or <code>/usr/lib/sendmail</code>, which is provided
by most mail transport agents, and is generally available on linux and
BSD systems.  It's also there on Mac&nbsp;OS&nbsp;X. However, if you don't have this,
it won't stop you from building darcs.

<P>
To use the <code>diff</code> command of darcs, a <code>diff</code> program supporting
options <code>-r</code> (recursive diff) and <code>-N</code> (show new files as
differences against an empty file) is required. The <code>configure</code>
script will look for <code>gdiff</code>, <code>gnudiff</code> and <code>diff</code> in this
order. You can force the use of another program by setting the <code>DIFF</code>
environment variable before running <code>configure</code>.

<P>
To rebuild the documentation (which should not be necessary since it is
included in html form with the tarballs), you will need to have latex
installed, as well as latex2html if you want to build it in html form.

<P>

<H1><A NAME="SECTION00320000000000000000">
Building on Mac&nbsp;OS&nbsp;X</A>
</H1>
To build on Mac&nbsp;OS&nbsp;X, you will need the Apple Developer Tools and the ghc
6.4 package installed.

<P>

<H1><A NAME="SECTION00330000000000000000">
Building on Microsoft Windows</A>
</H1>
To build on Microsoft Windows, you will need:

<P>

<UL>
<LI><A NAME="tex2html3"
  HREF="http://www.mingw.org/">MinGW</A>
which provides the GCC
  toolchain for win32.
</LI>
<LI><A NAME="tex2html4"
  HREF="http://www.mingw.org/msys.shtml">MSYS</A>
which provides
  a unix build environment for win32.  Be sure to download the separate
  msysDTK, autoconf and automake.
</LI>
<LI><A NAME="tex2html5"
  HREF="http://www.gzip.org/zlib/">zlib-1.2.1+</A>
library
  and headers.
</LI>
<LI><A NAME="tex2html6"
  HREF="http://curl.haxx.se/">curl-7.12.2+</A>
library
  and headers.
</LI>
<LI>If building with an SSL enabled curl you will need the OpenSSL
  libraries, unofficial builds are available at
  <A NAME="tex2html7"
  HREF="http://www.slproweb.com/products/Win32OpenSSL.html">http://www.slproweb.com/products/Win32OpenSSL.html</A>.
</LI>
</UL>

<P>
Copy the zlib and curl libraries and headers to both GHC and MinGW.  GHC
stores C headers in <code>&lt;ghc-dir&gt;/gcc-lib/include</code> and libraries in
<code>&lt;ghc-dir&gt;/gcc-lib</code>.  MinGW stores headers in
<code>&lt;mingw-dir&gt;/include</code> and libraries in <code>&lt;mingw-dir&gt;/lib</code>.

<P>
Set PATH to include the <code>&lt;msys-dir&gt;/bin</code>, <code>&lt;mingw-dir&gt;/bin</code>,
<code>&lt;curl-dir&gt;</code>, and a directory containing a pre-built darcs.exe if you
want the build's patch context stored for `<code>darcs --exact-version</code>'.

<P>
<PRE>
C:\darcs&gt; cd &lt;darcs-source-dir&gt;
C:\darcs&gt; sh

$ export GHC=/c/&lt;ghc-dir&gt;/bin/ghc.exe
$ autoconf
$ ./configure --disable-mmap --target=mingw
$ make
</PRE>

<P>

<H1><A NAME="SECTION00340000000000000000">
Building from tarball</A>
</H1>
If you get darcs from a tarball, the procedure (after unpacking the tarball
itself) is as follows:
<PRE>
% ./configure
% make
# Optional, but recommended to test compatibility with your environment.
% make test
% make install
</PRE>

<P>
There are options to configure that you may want to check out with
<PRE>
% ./configure --help
</PRE>

<P>
If your header files are installed in a non-standard location, you may need
to define the <code>CFLAGS</code> and <code>CPPFLAGS</code> environment variables to
include the path to the headers.  e.g. on NetBSD, you may need to run
<PRE>
% CFLAGS=-I/usr/pkg/include CPPFLAGS=-I/usr/pkg/include ./configure
</PRE>

<P>

<H1><A NAME="SECTION00350000000000000000">
Building darcs from the repository</A>
</H1>
To build the latest darcs from its repository, you will first need a
working copy of darcs. You can get darcs using:
<PRE>
% darcs get -v http://abridgegame.org/repos/darcs
</PRE>
and once you have the darcs repository you can bring it up to date with a
<PRE>
% darcs pull
</PRE>

<P>
The repository doesn't hold automatically generated files, which include
the configure script and the HTML documentation, so you need to run
<code>autoconf</code> first. 

<P>
You'll need <code>autoconf</code> 2.50 or higher. Some systems have more than one
version of <code>autoconf</code> installed. For example, <code>autoconf</code> may point to
version 2.13, while <code>autoconf259</code>  runs version 2.59. 

<P>
Also note that <code>make</code> is really "GNU make". On some systems, such as
the *BSDs, you may need to type <code>gmake</code> instead of make for this to work.

<P>
If you want to create readable documentation you'll need to have latex installed.
<PRE>
% autoconf
% ./configure
% make
% make install
</PRE>

<P>
If you want to tweak the configure options, you'll need to run <TT>  ./configure</TT> yourself after the make, and then run make again.

<P>

<H1><A NAME="SECTION00360000000000000000">
Building darcs with git</A>
</H1>

<P>
To enable git support, you first need to grab a copy of the git
source code; since darcs doesn't yet have the capability of accessing
remote git repositories, you'll have to either download a tarball or use
git itself to clone a git repository.  Compile git (no need to
install); this will create a file ``<code>libgit.a</code>''.  Then create a
symlink to the git source directory named ``<code>git</code>'' in your darcs
source directory, configure darcs using the ``<code>--enable-git</code>''
option, and build darcs as usual.

<P>

<H1><A NAME="SECTION00370000000000000000">
Submitting patches to darcs</A>
</H1>
I know, this doesn't really belong in this chapter, but if you're using the
repository version of darcs it's really easy to submit patches to me using
darcs. In fact, even if you don't know any Haskell, you could submit fixes
or additions to this document (by editing <code>building_darcs.tex</code>) based
on your experience building darcs...

<P>
To do so, just record your changes (which you made in the darcs repository)
<PRE>
% darcs record --no-test
</PRE>
making sure to give the patch a nice descriptive name.  The
<code>--no-test</code> options keeps darcs from trying to run the unit tests,
which can be rather time-consuming.  Then you can send the patch to the
darcs-devel mailing list by email by
<PRE>
% darcs send -u
</PRE>
The darcs repository stores the email address to which patches should be
sent by default.  The email address you see is actually my own, but when
darcs notices that you haven't signed the patch with my GPG key, it will
forward the message to darcs-devel.

<P>

<H1><A NAME="SECTION00400000000000000000">
Getting started</A>
</H1>

<P>
This chapter will lead you through an example use of darcs, which hopefully
will allow you to get started using darcs with your project.

<P>

<H1><A NAME="SECTION00410000000000000000">
Creating your repository</A>
</H1>

<P>
Creating your repository in the first place just involves telling darcs to
create the special directory (called <TT>_darcs</TT>) in your project tree,
which will hold the revision information.  This is done by simply calling
from the root directory of your project:
<PRE>
% cd my_project/
% darcs initialize
</PRE>
This creates the <code>_darcs</code> directory and populates it with whatever
files and directories are needed to describe an empty project.  You now
need to tell darcs what files and directories in your project should be
under revision control.  You do this using the command <code>darcs add</code><A NAME="tex2html8"
  HREF="#foot199"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A>:
<PRE>
% darcs add *.c Makefile.am configure.ac
</PRE>
When you have added all your files (or at least, think you have), you will
want to record your changes.  ``Recording'' always includes adding a note
as to why the change was made, or what it does.  In this case, we'll just
note that this is the initial version.
<PRE>
% darcs record --all
What is the patch name? Initial revision.
</PRE>
Note that since we didn't specify a patch name on the command line we were
prompted for one.  If the environment variable `EMAIL' isn't set, you will
also be prompted for your email address.  Each patch that is recorded is
given a unique identifier consisting of the patch name, its creator's email
address, and the date when it was created.

<P>

<H1><A NAME="SECTION00420000000000000000">
Making changes</A>
</H1>

<P>
Now that we have created our repository, make a change to one or more of
your files.  After making the modification run:
<PRE>
% darcs whatsnew
</PRE>
This should show you the modifications that you just made, in the darcs
patch format.  If you prefer to see your changes in a different format,
read Section&nbsp;<A HREF="#whatsnew"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>, which describes the whatsnew command in
detail.

<P>
Let's say you have now made a change to your project.  The next thing to do
is to record a patch.  Recording a patch consists of grouping together a
set of related changes, and giving them a name.  It also tags the patch
with the date it was recorded and your email address.

<P>
To record a patch simply type:
<PRE>
% darcs record
</PRE>
darcs will then prompt you with all the changes that you have made that
have not yet been recorded, asking you which ones you want to include in
the new patch.  Finally, darcs will ask you for a name for the patch.

<P>
You can now rerun whatsnew, and see that indeed the changes you have
recorded are no longer marked as new.

<P>

<H1><A NAME="SECTION00430000000000000000">
Making your repository visible to others</A>
</H1>
How do you let the world know about these wonderful changes?  Obviously,
they must be able to see your repository.  Currently the easiest way to do
this is typically by http using any web server.  The recommended way to do
this (using apache in a UNIX environment) is to create a directory called
<TT>/var/www/repos</TT>, and then put a symlink to your repo there:
<PRE>
% cd /var/www/repos
% ln -s /home/username/myproject .
</PRE>

<P>
As long as you're running a web server and making your repo available to
the world, you may as well make it easy for people to see what changes
you've made.  You can do this by running <code>make installserver</code>, which
installs the program <code>darcs_cgi</code> at <code>/usr/lib/cgi-bin/darcs</code>.  You
also will need to create a cache directory named
<code>/var/cache/darcs_cgi</code>, and make sure the owner of that directory is
the same user that your web server runs its cgi scripts as.  For me,
this is www-data.  Now your friends and enemies should be able to easily
browse your repos by pointing their web browsers at
<code>http://your.server.org/cgi-bin/darcs</code>.

<P>

<H1><A NAME="SECTION00440000000000000000">
Getting changes made to another repository</A>
</H1>
Ok, so I can now browse your repository using my web browser... so
what? How do I get your changes into <SPAN  CLASS="textit">my</SPAN> repository, where they can
do some good? It couldn't be easier.  I just <code>cd</code> into my repository,
and there type:
<PRE>
% darcs pull http://your.server.org/repos/yourproject
</PRE>
Darcs will check to see if you have recorded any changes that aren't in my
current repository.  If so, it'll prompt me for each one, to see which ones
I want to add to my repository.  Note that you may see a different series
of prompts depending on your answers, since sometimes one patch depends on
another, so if you answer yes to the first one, you won't be prompted for
the second if the first depends on it.

<P>
Of course, maybe I don't even have a copy of your repository.  In that case
I'd want to do a
<PRE>
% darcs get http://your.server.org/repos/yourproject
</PRE>
which gets the whole repo.

<P>
I could instead create an empty repository and fetch all of your patches
with pull.  Get is just a more efficient way to clone a whole repository.

<P>
Get, pull and push also work over ssh.  Ssh-paths are of the same form
accepted by scp, namely <code>[username@]host:/path/to/repository</code>.

<P>

<H1><A NAME="SECTION00450000000000000000">
Moving patches from one repo to another</A>
</H1>

<P>
Darcs is flexible as to how you move patches from one repo to another.
This section will introduce all the ways you can get patches from one place
to another, starting with the simplest and moving to the most complicated.

<P>

<H2><A NAME="SECTION00451000000000000000">
All pulls</A>
</H2>

<P>
The simplest method is the ``all-pull'' method.  This involves making each
repository readable (by http, ftp, nfs-mounted disk, whatever), and you
run <code>darcs pull</code> in the repo you want to move the patch to.  This is nice,
as it doesn't require you to give write access to anyone else, and is
reasonably simple.

<P>

<H2><A NAME="SECTION00452000000000000000">
Send and apply manually</A>
</H2>

<P>
Sometimes you have a machine on which it is not convenient to set up a web
server, perhaps because it's behind a firewall or perhaps for security
reasons, or because it is often turned off.  In this case you can use darcs
send from that computer to generate a patch bundle destined for another
repository.  You can either let darcs email the patch for you, or save it
as a file and transfer it by hand.  Then in the destination repository you
(or the owner of that repo) run darcs apply to apply the patches contained
in the bundle.  This is also quite a simple method since, like the all-pull
method, it doesn't require that you give anyone write access to your
repository.  But it's less convenient, since you have to keep track of the
patch bundle (in the email, or whatever).

<P>
If you use the send and apply method with email, you'll probably want to
create a <code>_darcs/prefs/email</code> file containing your email address.
This way anyone who sends to your repository will automatically send the
patch bundle to your email address.

<P>
If you receive many patches by email, you probably will benefit by running
darcs apply directly from your mail program.  I have in my <code>.muttrc</code>
the following
<PRE>
macro pager A "&lt;pipe-entry&gt;darcs apply --verbose --mark-conflicts \
        --reply droundy@abridgegame.org --repodir ~/darcs"
</PRE>
which allows me to apply patches directly from <code>mutt</code>, sending a
confirmation email to the person who sent me the patch.

<P>

<H2><A NAME="SECTION00453000000000000000">
Push</A>
</H2>

<P>
If you use ssh (and preferably also ssh-agent, so you won't have to keep
retyping your password), you can use the push method to transfer changes
(using the scp protocol for communication).  This method is again not very
complicated, since you presumably already have the ssh permissions set up.
Push can also be used when the target repository is local, in which case
ssh isn't needed.  On the other hand, in this situation you could as easily
run a pull, so there isn't much benefit.

<P>
Note that you can use push to administer a multiple-user repository.  You
just need to create a user for the repository (or repositories), and give
everyone with write access ssh access, perhaps using
<code>.ssh/authorized_keys</code>.  Then they run
<PRE>
% darcs push repouser@repo.server:repo/directory
</PRE>

<P>

<H2><A NAME="SECTION00454000000000000000">
Push --apply-as</A>
</H2>

<P>
Now we get more subtle.  If you like the idea in the previous paragraph
about creating a repository user to own a repository which is writable by
a number of users, you have one other option.

<P>
Push <code>--apply-as</code> can run on either a local repository or one accessed
with ssh, but uses <code>sudo</code> to run a darcs apply command (having created
a patch bundle as in send) as another user.  You can add the following line
in your sudoers file to allow the users to apply their patches to a
centralized repository:
<PRE>
ALL     ALL = (repo-user) NOPASSWD: /usr/bin/darcs apply --all --repodir /repo/path*
</PRE>
This method is ideal for a centralized repository when all the users have
accounts on the same computer, if you don't want your users to be able to
run arbitrary commands as repo-user.

<P>

<H2><A NAME="SECTION00455000000000000000">
Sending signed patches by email</A>
</H2>

<P>
Most of the previous methods are a bit clumsy if you don't want to give
each person with write access to a repo an account on your server.  Darcs
send can be configured to send a cryptographically signed patch by email.
You can then set up your mail system to have darcs verify that patches were
signed by an authorized user and apply them when a patch is received by
email.  The results of the apply can be returned to the user by email.
Unsigned patches (or patches signed by unauthorized users) will be
forwarded to the repository owner (or whoever you configure them to be
forwarded to...).

<P>
This method is especially nice when combined with the <code>--test</code> option
of darcs apply, since it allows you to run the test suite (assuming you
have one) and reject patches that fail--and it's all done on the server,
so you can happily go on working on your development machine without
slowdown while the server runs the tests.

<P>
Setting up darcs to run automatically in response to email is by far the
most complicated way to get patches from one repo to another... so it'll
take a few sections to explain how to go about it.

<P>

<H4><A NAME="SECTION00455010000000000000">
Security considerations</A>
</H4>

<P>
When you set up darcs to run apply on signed patches, you should assume
that a user with write access can write to any file or directory that is
writable by the user under which the apply process runs.  Unless you
specify the <code>--no-test</code> flag to darcs apply (and this is <SPAN  CLASS="textit">not</SPAN>
the default), you are also allowing anyone with write access to that
repository to run arbitrary code on your machine (since they can run a test
suite--which they can modify however they like).  This is quite a
potential security hole.

<P>
For these reasons, if you don't implicitly trust your users, it is
recommended that you create a user for each repository to limit the damage
an attacker can do with access to your repository.  When considering who to
trust, keep in mind that a security breach on any developer's machine could
give an attacker access to their private key and passphrase, and thus to
your repository.

<P>

<H4><A NAME="SECTION00455020000000000000">
Installing necessary programs</A>
</H4>

<P>
You also must install the following programs: gnupg, a mailer configured to
receive mail (e.g. exim, sendmail or postfix), and a web server (usually
apache).  If you want to be able to browse your repository on the web you
must also configure your web server to run cgi scripts and make sure the
darcs cgi script was properly installed (by either a darcs-server package,
or `make install-server').

<P>

<H4><A NAME="SECTION00455030000000000000">
Setting up a repository with its own user</A>
</H4>

<P>
To create a repository, as root run the `<code>darcs-createrepo</code>'.  You
will be prompted for the email address of the repository and the location
of an existing copy of the repository.  If your desired email is
``myproject@my.url'', this will create a user named ``myproject'' with a
home directory of <code>/var/lib/darcs/repos/myproject</code>. FIXME:  I have no
idea if the darcs-createrepo program will even run on any system other than
debian.  Success reports would be appreciated (or of course bug reports if
it fails).

<P>
The ``myproject'' user will be configured to run the darcs patcher on any
emails it receives.  However, the patcher will bounce any emails which
aren't signed by a key in the
<code>/var/lib/darcs/repos/myproject/allowed_keys</code> gpg keyring (which is
empty).  To give yourself access to this repository you will need to create
a gpg key.  If you don't know about public key cryptography, take a look at
the gnupg manual.

<P>

<H4><A NAME="SECTION00455040000000000000">
Granting access to a repository</A>
</H4>

<P>
You create your gpg key by running (as your normal user):
<PRE>
% gpg --gen-key
</PRE>
You will be prompted for your name and email address, among other options.
To add your public key to the allowed keys keyring.  Of course, you can
skip this step if you already have a gpg key you wish to use.

<P>
You now need to export the public key so we can tell the patcher about it.
You can do this with the following command (again as your normal user):
<PRE>
% gpg --export "email@address" &gt; /tmp/exported_key
</PRE>
And now we can add your key to the <code>allowed_keys</code>:
<PRE>
(as root)&gt; gpg --keyring /var/lib/darcs/repos/myproject/allowed_keys \
               --no-default-keyring --import /tmp/exported_key
</PRE>
You can repeat this process any number of times to authorize multiple users
to send patches to the repository.

<P>
You should now be able to send a patch to the repository by running as your
normal user, in a working copy of the repository:
<PRE>
% darcs send --sign http://your.computer/repos/myproject
</PRE>
You may want to add ``send sign'' to the file <code>_darcs/prefs/defaults</code>
so that you won't need to type <code>--sign</code> every time you want to
send...

<P>
If your gpg key is protected by a passphrase, then executing <code>send</code>
with the <code>--sign</code> option might give you the following error:
<PRE>
darcs failed:  Error running external program 'gpg'
</PRE>
The most likely cause of this error is that you have a misconfigured
gpg that tries to automatically use a non-existent gpg-agent
program. GnuPG will still work without gpg-agent when you try to sign
or encrypt your data with a passphrase protected key. However, it will
exit with an error code 2 (<code>ENOENT</code>) causing <code>darcs</code> to
fail. To fix this, you will need to edit your <code>~/.gnupg/gpg.conf</code>
file and comment out or remove the line that says:
<PRE>
use-agent
</PRE>
If after commenting out or removing the <code>use-agent</code> line in your
gpg configuration file you still get the same error, then you probably
have a modified GnuPG with use-agent as a hard-coded option. In that
case, you should change <code>use-agent</code> to <code>no-use-agent</code> to
disable it explicitly.

<P>

<H4><A NAME="SECTION00455050000000000000">
Setting up a sendable repository using procmail</A>
</H4>
If you don't have root access on your machine, or perhaps simply don't want
to bother creating a separate user, you can set up a darcs repository using
procmail to filter your mail.  I will assume that you already use procmail
to filter your email.  If not, you will need to read up on it, or perhaps
should use a different method for routing the email to darcs.

<P>
To begin with, you must configure your repository so that a darcs send to
your repository will know where to send the email.  Do this by creating a
file in <code>/path/to/your/repo/_darcs/prefs</code> called <code>email</code>
containing your email address.  As a trick (to be explained below), we will
create the email address with ``darcs repo'' as your name, in an email
address of the form ``David Roundy <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg1.png"
 ALT="$&lt;$"></SPAN>droundy@abridgegame.org<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg2.png"
 ALT="$&gt;$"></SPAN>.''
<PRE>
% echo 'my darcs repo &lt;user@host.com&gt;' &gt; /path/to/your/repo/_darcs/prefs/email
</PRE>

<P>
The next step is to set up a gnupg keyring containing the public keys of
people authorized to send to your repo.  Here I'll give a second way of
going about this (see above for the first).  This time I'll assume you
want to give me write access to your repository.  You can do this by:
<PRE>
gpg --no-default-keyring \
    --keyring /path/to/the/allowed_keys --recv-keys D3D5BCEC
</PRE>
This works because ``D3D5BCEC'' is the ID of my gpg key, and I have
uploaded my key to the gpg keyservers.  Actually, this also requires that
you have configured gpg to access a valid keyserver.  You can, of course,
repeat this command for all keys you want to allow access to.

<P>
Finally, we add a few lines to your <code>.procmailrc</code>:
<PRE>
:0:
* ^TOmy darcs repo
|(umask 022; darcs apply --reply user@host.com \
    --repodir /path/to/your/repo --verify /path/to/the/allowed_keys)
</PRE>
The purpose for the ``my darcs repo'' trick is partially to make it easier
to recognize patches sent to the repository, but is even more crucial to
avoid nasty bounce loops by making the <code>--reply</code> option have an email
address that won't go back to the repository.  This means that unsigned
patches that are sent to your repository will be forwarded to your ordinary
email.

<P>
I find that I need the ``umask 022'' in order to keep procmail from setting
the umask incorrectly, which causes the repository to no longer be
world-readable.

<P>

<H4><A NAME="SECTION00455060000000000000">
Checking if your e-mail patch was applied</A>
</H4>

<P>
After sending a patch with <code>darcs send</code>, you may not receive any feedback,
even if the patch is applied. You can confirm whether or not your patch was applied
to the remote repo by pointing <code>darcs changes</code> at a remote repo:
<PRE>
darcs changes --last=10 --repo=http://abridgegame.org/repos/darcs
</PRE>

<P>
That shows you the last 10 changes in the remote repo. You can adjust the options given
to <code>changes</code> if a more advanced query is needed.

<P>

<H1><A NAME="SECTION00460000000000000000"></A>
<A NAME="disk-usage"></A>
<BR>
Reducing disk space usage
</H1>

<P>
A Darcs repository contains the patches that Darcs uses to store
history, the working directory, and a <SPAN  CLASS="textit">pristine tree</SPAN> (a copy of
the working directory files with no local modifications).  For large
repositories, this can add up to a fair amount of disk usage.

<P>
There are two techniques that can be used to reduce the amount of
space used by Darcs repositories: linking and using no pristine tree.
The former can be used on any repository; the latter is only suitable
in special circumstances, as it makes some operations much slower.

<P>

<H2><A NAME="SECTION00461000000000000000">
Linking between repositories</A>
</H2>

<P>
A number of filesystems support <SPAN  CLASS="textit">linking</SPAN> files, sharing a
single file data between different directories.  Under some
circumstances, when repositories are very similar (typically because
they represent different branches of the same piece of software),
Darcs will use linking to avoid storing the same file multiple times.

<P>
Whenever you invoke <code>darcs get</code> to copy a repository from a local
filesystem onto the same filesystem, Darcs will link patches whenever
possible.

<P>
In order to save time, <code>darcs get</code> does not link pristine trees
even when individual files are identical.  Additionally, as you pull
patches into trees, patches will become unlinked.  This will result in
a lot of wasted space if two repositories have been living for a long
time but are similar.  In such a case, you should <SPAN  CLASS="textit">relink</SPAN> files
between the two repositories.

<P>
Relinking is an asymmetric operation: you relink one repository (to
which you must have write access) to another repository, called the
<SPAN  CLASS="textit">sibling</SPAN>.  This is done with <code>darcs optimize --relink</code>, with
-the <code>--sibling</code> flag specifying the sibling.
<PRE>
  $ cd /var/repos/darcs-unstable
  $ darcs optimize --relink --sibling /var/repos/darcs
</PRE>
The <code>--sibling</code> flag can be repeated multiple times, in which
case Darcs will try to find a file to link to in all of the siblings.
If a default repository is defined, Darcs will try, as a last resort,
to link against the default repository.

<P>
Additional space savings can be achieved by relinking files in the
pristine tree (see below) by using the <code>--relink-pristine</code> flag.
However, doing this prevents Darcs from having precise timestamps on
the pristine files, which carries a moderate performance penalty.

<P>

<H2><A NAME="SECTION00462000000000000000">
Alternate formats for the pristine tree</A>
</H2>

<P>
By default, every Darcs repository contains a complete copy of the
<SPAN  CLASS="textit">pristine tree</SPAN>, the working tree as it would be if there were no
local edits.  By avoiding the need to consult a possibly large number
of patches just to find out if a file is modified, the pristine tree
makes a lot of operations much faster than they would otherwise be.

<P>
Under some circumstances, keeping a whole pristine tree is not
desirable.  This is the case when preparing a repository to back up,
when publishing a repository on a public web server with limited
space, or when storing a repository on floppies or small USB keys.  In
such cases, it is possible to use a repository with no pristine tree.

<P>
Darcs automatically recognizes a repository with no pristine
tree.  In order to create such a tree, specify the
<code>--no-pristine-tree</code> flag to <code>darcs initialize</code> or
<code>darcs get</code>.  There is currently no way to switch an existing
repository to use no pristine tree.

<P>
The support for <code>--no-pristine-tree</code> repositories is fairly new,
and has not been extensively optimized yet.  Please let us know if you
use this functionality, and which operations you find are too slow.

<P>

<H1><A NAME="SECTION00500000000000000000"></A><A NAME="configuring"></A>
<BR>
Configuring darcs
</H1>

<P>
There are several ways you can adjust darcs' behavior to suit your needs.
The first is to edit files in the <code>_darcs/prefs/</code> directory of a
repository.  Such configuration only applies when working with that
repository.  To configure darcs on a per-user rather than per-repository
basis (but with essentially the same methods), you can edit (or create)
files in the <code>~/.darcs/</code> directory.  Finally, the behavior of some
darcs commands can be modified by setting appropriate environment
variables.

<P>

<H1><A NAME="SECTION00510000000000000000">
prefs</A>
</H1>

<P>
The <code>_darcs</code> directory contains a <code>prefs</code>  directory.  This
directory exists simply to hold user configuration settings specific to
this repository.  The contents of this directory are intended to be
modifiable by the user, although in some cases a mistake in such a
modification may cause darcs to behave strangely.

<P>

<H4><A NAME="SECTION00510010000000000000"></A><A NAME="defaults"></A>
<BR>
defaults
</H4>

<P>
Default values for darcs commands can be configured on a per-repository
basis by editing (and possibly creating) the <code>_darcs/prefs/defaults</code>
file.  Each line of this file has the following form:
<PRE>
COMMAND FLAG VALUE
</PRE>
where <code>COMMAND</code> is either the name of the command to which the default
applies, or <code>ALL</code> to indicate that the default applies to all commands
accepting that flag.  The <code>FLAG</code> term is the name of the long argument
option without the ``<code>--</code>'', i.e. <code>verbose</code> rather than
<code>--verbose</code>.  Finally, the <code>VALUE</code> option can be omitted if the
flag is one such as <code>verbose</code> that doesn't involve a value.
Each line only takes one flag.  To set multiple defaults for the same
command (or for <code>ALL</code> commands), use multiple lines.

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><TT><code>~/.darcs/defaults</code></TT></TD>
<TD ALIGN="LEFT"><TT>provides defaults for this user account</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT><code>project/_darcs/prefs/defaults</code></TT></TD>
<TD ALIGN="LEFT"><TT>provides defaults for one project, overrules changes per user</TT></TD>
</TR>
</TABLE>

<P>
For example, if your system clock is bizarre, you could instruct darcs to
always ignore the file modification times by adding the following line to
your <code>_darcs/prefs/defaults</code> file.  (Note that this would have to be
done for each repository!)
<PRE>
ALL ignore-times
</PRE>

<P>
If you never want to run a test when recording to a particular repository
(but still want to do so when running check on that repo), and like to name
all your patches ``Stupid patch'', you could use the following:
<PRE>
record no-test
record patch-name Stupid patch
</PRE>

<P>
If you would like a command to be run every time patches are recorded
in a particular repository (for example if you have one central
repository, that all developers contribute to), then you can set apply
to always run a command when apply is successful.  For example, if you
need to make sure that the files in the repository have the correct
access rights you might use the following.  There are two things
to note about using darcs this way:

<UL>
<LI>Without the second line you will get errors, because the sub
      process that runs apply cannot prompt interactively.
</LI>
<LI>Whatever script is run by the post apply command should not be
      be added to the repository with <code>darcs add</code>; doing so would
      allow people to modify that file and then run arbitrary scripts on
      your main repository, possibly damaging or violating security.
</LI>
</UL>
<PRE>
apply posthook chmod -R a+r *
apply run-posthook
</PRE> 

<P>
There are some options which are meant specifically for use in
<code>_darcs/prefs/defaults</code>. One of them is <code>--disable</code>. As the name
suggests, this option will disable every command that got it as argument. So,
if you are afraid that you could damage your repositories by inadvertent use of
a command like amend-record, add the following line to
<code>_darcs/prefs/defaults</code>:
<PRE>
amend-record disable
</PRE>

<P>
Also, a global preferences file can be created with the name
<code>.darcs/defaults</code> in your home directory. Options present there will
be added to the repository-specific preferences.
If they conflict with repository-specific options, the repository-specific
ones will take precedence.

<P>

<H4><A NAME="SECTION00510020000000000000">
repos</A>
</H4>
The <code>_darcs/prefs/repos</code> file contains a list of repositories you have
pulled from or pushed to, and is used for autocompletion of pull and push
commands in bash.  Feel free to delete any lines from this list that might
get in there, or to delete the file as a whole.

<P>

<H4><A NAME="SECTION00510030000000000000"></A><A NAME="author_prefs"></A>
<BR>
author
</H4>
The <code>_darcs/prefs/author</code> file contains the email address (or name) to
be used as the author when patches are recorded in this repository,
e.g. <code>David Roundy &lt;droundy@abridgegame.org&gt;</code>.  This
file overrides the contents of the environment variables
<code>$DARCS_EMAIL</code> and <code>$EMAIL</code>.

<P>

<H4><A NAME="SECTION00510040000000000000">
boring</A>
</H4>
The <code>_darcs/prefs/boring</code> file may contain a list of regular
expressions describing files, such as object files, that you do not expect
to add to your project.  As an example, the boring file that I use with
my darcs repository is:
<PRE>
\.hi$
\.o$
^\.[^/]
^_
~$
(^|/)CVS($|/)
</PRE>
A newly created repository has a longer boring file that
includes many common source control, backup, temporary, and compiled files.

<P>
You may want to have the boring file under version
control.  To do this you can use darcs setpref to set the value
``boringfile'' to the name of your desired boring file (e.g. ``darcs
setpref boringfile .boring'', where .boring is the repository path of a file
that has been
darcs added to your repository).  The boringfile pref overrides
<code>_darcs/prefs/boring</code>, so be sure to copy that file to the boringfile.

<P>
You can also set up a ``boring'' regexps
file in your home directory, named <code>~/.darcs/boring</code>, which will be
used with all of your darcs repositories.

<P>
Any file whose repository path (such as <code>manual/index.html</code>) matches any of
the boring regular expressions is considered boring.  The boring file is
used to filter the files provided to darcs add, to allow you to use a
simple ``darcs add newdir newdir/*'' without accidentally adding a bunch of
object files.  It is also used when the <code>--look-for-adds</code> flag is
given to whatsnew or record.

<P>

<H4><A NAME="SECTION00510050000000000000">
binaries</A>
</H4>
The <code>_darcs/prefs/binaries</code> file may contain a list of regular
expressions describing files that should be treated as binary files rather
than text files.  You probably will want to have the binaries file under
version control.  To do this you can use darcs setpref to set the value
``binariesfile'' to the name of your desired binaries file (e.g. ``darcs
setpref binariesfile ./.binaries'', where .binaries is a file that has been
darcs added to your repository).  As with the boring file, you can also set
up a <code>~/.darcs/binaries</code> file if you like.

<P>

<H4><A NAME="SECTION00510060000000000000">
email</A>
</H4>
The <code>_darcs/prefs/email</code> file is used to provide the e-mail address for your  
repo that others will use when they <code>darcs send</code> a patch back to you.
The contents of the file should simply be an e-mail address.

<P>

<H4><A NAME="SECTION00510070000000000000">
motd</A>
</H4>
The <code>_darcs/prefs/motd</code> file may contain a ``message of the day''
which will be displayed to users who get or pull from the repo without the
<code>--quiet</code> option.

<P>

<H1><A NAME="SECTION00520000000000000000">
Environment variables</A>
</H1>

<P>
There are a few environment variables whose contents affect darcs'
behavior.

<P>

<H4><A NAME="SECTION00520010000000000000">
DARCS_EMAIL</A>
</H4>
The DARCS_EMAIL environment variable determines the ``author'' name used
by darcs when recording if no <code>_darcs/prefs/author</code> exists.  If
DARCS_EMAIL is undefined, the contents of the EMAIL environment variable
are used.

<P>

<H4><A NAME="SECTION00520020000000000000">
DARCS_EDITOR</A>
</H4>
When pulling up an editor (for example, when adding a long comment in
record), darcs uses the contents of DARCS_EDITOR if it is defined.  If
not, it tries the contents of VISUAL, and if that isn't defined (or fails
for some reason), it tries EDITOR.  If none of those environment variables
are defined, darcs tries <code>vi</code>, <code>emacs</code>, <code>emacs -nw</code> and
<code>nano</code> in that order.

<P>

<H4><A NAME="SECTION00520030000000000000">
DARCS_TMPDIR</A>
</H4>
If the environment variable DARCS_TMPDIR is defined, darcs will use that
directory for its temporaries.  Otherwise it will use TMPDIR, if that is
defined, and if not that then <code>/tmp</code> and if <code>/tmp</code> doesn't exist,
it'll put the temporaries in <code>_darcs</code>.

<P>
This is very helpful, for example, when recording with a test suite that
uses MPI, in which case using <code>/tmp</code> to hold the test copy is no good,
as <code>/tmp</code> isn't shared over NFS and thus the <code>mpirun</code> call will
fail, since the binary isn't present on the compute nodes.

<P>

<H4><A NAME="SECTION00520040000000000000">
HOME</A>
</H4>
HOME is used to find the per-user prefs directory, which is located at
<code>$HOME/.darcs</code>.

<P>

<H4><A NAME="SECTION00520050000000000000">
TERM</A>
</H4>
If darcs is compiled with libcurses support and support for color output,
it uses the environment variable TERM to decide whether or not color is
supported on the output terminal.

<P>

<H4><A NAME="SECTION00520060000000000000">
SSH_PORT</A>
</H4>
When using ssh, if the SSH_PORT environment variable is defined, darcs will
use that port rather than the default ssh port (which is 22).

<P>

<H4><A NAME="SECTION00520070000000000000"></A>
<A NAME="darcsssh"></A>
<BR>
DARCS_SSH
</H4>
The DARCS_SSH environment variable defines the command that darcs will use
when asked to run ssh.  This command is <SPAN  CLASS="textit">not</SPAN> interpreted by a shell,
so you cannot use shell metacharacters, and the first word in the command
must be the name of an executable located in your path.

<P>

<H4><A NAME="SECTION00520080000000000000">
DARCS_SCP and DARCS_SFTP</A>
</H4>
The DARCS_SCP and DARCS_SFTP environment variables define the
commands that darcs will use when asked to run scp or sftp.  Note that
scp and sftp is how darcs accesses repositories whose URL is of the
form <code>user@foo.org:foo</code> or <code>foo.org:foo</code>.  Darcs will use
scp to copy single files (e.g. repository meta-information), and sftp
to copy multiple files in batches (e.g. patches).  These commands are
<SPAN  CLASS="textit">not</SPAN> interpreted by a shell, so you cannot use shell
metacharacters, and the first word in the command must be the name of
an executable located in your path.

<P>

<H4><A NAME="SECTION00520090000000000000">
DARCS_PROXYUSERPWD</A>
</H4>
This environment variable allows DARCS and libcurl to access remote repositories
via a password-protected HTTP proxy. The proxy itself is specified with the standard
environment variable for this purpose, namely 'http_proxy'. The DARCS_PROXYUSERPWD
environment variable specifies the proxy username and password. It must be given in 
the form <SPAN  CLASS="textit">username:password</SPAN>.

<P>

<H4><A NAME="SECTION005200100000000000000">
DARCS_GET_FOO, DARCS_MGET_FOO and DARCS_APPLY_FOO</A>
</H4>
When trying to access a repository with a url beginning foo://,
darcs will invoke the program specified by the DARCS_GET_FOO
environment variable (if defined) to download each file, and the
command specified by the DARCS_APPLY_FOO environment variable (if
defined) when pushing to a foo:// url.  

<P>
This method overrides all other ways of getting <code>foo://xxx urls</code>.

<P>
Note that each command should be constructed so that it sends the downloaded
content to STDOUT, and the next argument to it should be the URL. Here are some
examples that should work for DARCS_GET_HTTP:

<P>
<PRE>
fetch -q -o -  
curl -s -f
lynx -source 
wget -q -O -
</PRE>

<P>
If set, DARCS_MGET_FOO
will be used to fetch many files from a single repository simultaneously.
Replace FOO and foo as appropriate to handle other URL schemes.
These commands are <SPAN  CLASS="textit">not</SPAN> interpreted by a shell, so you cannot
use shell metacharacters, and the first word in the command must
be the name of an executable located in your path. The GET command
will be called with a url for each file, the MGET command will be
invoked with a number of urls and is expected to download the files
to the current directory, preserving the filename but not the path,
the APPLY command will be called with a darcs patchfile piped into
its standard input. Example:

<P>
<PRE>
wget -q
</PRE>

<P>

<H4><A NAME="SECTION005200110000000000000">
DARCS_MGETMAX</A>
</H4>
When invoking a DARCS_MGET_FOO command, darcs will limit the
number of urls presented to the command to the value of this variable,
if set, or 200.

<P>

<H4><A NAME="SECTION005200120000000000000">
DARCS_WGET</A>
</H4>
This is a very old option that is only used if libcurl is not compiled
in and one of the DARCS_GET_FOO is not used. Using one of those
is recommended instead.

<P>
The DARCS_WGET environment variable defines the command that darcs
will use to fetch all URLs for remote repositories.  The first word in
the command must be the name of an executable located in your path.
Extra arguments can be included as well, such as:

<P>
<PRE>
wget -q
</PRE>

<P>
Darcs will append <code>-i</code> to the argument list, which it uses to provide a
list of URLS to download. This allows wget to download multiple patches at the
same time. It's possible to use another command besides <code>wget</code> with this
environment variable, but it must support the <code>-i</code> option in the same way. 

<P>
These commands are <SPAN  CLASS="textit">not</SPAN> interpreted by a shell, so you cannot use shell
meta-characters.

<P>

<H1><A NAME="SECTION00530000000000000000">
Highlighted output</A>
</H1>

<P>
If the terminal understands ANSI color codes,
darcs will highlight certain keywords and delimiters when printing patches.
This can be turned off by setting the environment variable DARCS_DONT_COLOR to 1.
If you use a pager that happens to understands ANSI colors, like <code>less -R</code>,
darcs can be forced to always highlight the output
by setting DARCS_ALWAYS_COLOR to 1.
If you can't see colors you can set DARCS_ALTERNATIVE_COLOR to 1,
and darcs will use ANSI codes for bold and reverse video instead of colors.

<P>
By default darcs will escape (by highlighting if possible) any kind of spaces at the end of lines
when showing patch contents.
If you don't want this you can turn it off by setting
DARCS_DONT_ESCAPE_TRAILING_SPACES to 1.
A special case exists for only carriage returns:
DARCS_DONT_ESCAPE_TRAILING_CR.

<P>

<H1><A NAME="SECTION00540000000000000000">
Character escaping and non-ASCII character encodings</A>
</H1>

<P>
Darcs needs to escape certain characters when printing patch contents to a terminal.
Characters like <SPAN  CLASS="textit">backspace</SPAN> can otherwise hide patch content from the user,
and other character sequences can even in some cases redirect commands to the shell
if the terminal allows it.

<P>
By default darcs will only allow printable 7-bit ASCII characters (including space),
and the two control characters <SPAN  CLASS="textit">tab</SPAN> and <SPAN  CLASS="textit">newline</SPAN>.
(See the last paragraph in this section for a way to tailor this behavior.)
All other octets are printed in quoted form (as <code>^&lt;control letter&gt;</code> or <code>\<hex code&gt;</code>).

<P>
Darcs has some limited support for locales.
If the systems locale is a single-byte character encoding,
like the Latin encodings,
you can set the environment variable DARCS_DONT_ESCAPE_ISPRINT to 1
and darcs will display all the printables in the current system locale
instead of just the ASCII ones.
NOTE: This does curently not work on some architectures if darcs is
compiled with GHC&nbsp;6.4. Some non-ASCII control characters might be printed
and can possibly spoof the terminal.

<P>
For multi-byte character encodings things are less smooth.
UTF-8 will work if you set DARCS_DONT_ESCAPE_8BIT to 1,
but non-printables outside the 7-bit ASCII range are no longer escaped.
E.g., the extra control characters from Latin1
might leave your terminal at the mercy of the patch contents.
Space characters outside the 7-bit ASCII range are no longer recognized
and will not be properly escaped at line endings.

<P>
As a last resort you can set DARCS_DONT_ESCAPE_ANYTHING to 1.
Then everything that doesn't flip code sets should work,
and so will all the bells and whistles in your terminal.
This environment variable can also be handy
if you pipe the output to a pager or external filter
that knows better than darcs how to handle your encoding.
Note that <SPAN  CLASS="textit">all</SPAN> escaping,
including the special escaping of any line ending spaces,
will be turned off by this setting.

<P>
There are two environment variables you can set
to explicitly tell darcs to not escape or escape octets.
They are
DARCS_DONT_ESCAPE_EXTRA and DARCS_ESCAPE_EXTRA.
Their values should be strings consisting of the verbatim octets in question.
The do-escapes take precedence over the dont-escapes.
Space characters are still escaped at line endings though.
The special environment variable DARCS_DONT_ESCAPE_TRAILING_CR
turns off escaping of carriage return last on the line (DOS style).

<P>

<H1><A NAME="SECTION00600000000000000000">
Best practices</A>
</H1>

<P>

<H1><A NAME="SECTION00610000000000000000">
Introduction</A>
</H1>

<P>
This chapter is intended to review various scenarios and describe in each
case effective ways of using darcs.  There is no one ``best practice'', and
darcs is a sufficiently low-level tool that there are many high-level ways
one can use it, which can be confusing to new users.  The plan (and hope)
is that various users will contribute here describing how they use darcs in
different environments.  However, this is not a wiki, and contributions
will be edited and reviewed for consistency and wisdom.

<P>

<H1><A NAME="SECTION00620000000000000000">
Creating patches</A>
</H1>

<P>
This section will lay down the concepts around patch creation.
The aim is to develop a way of thinking
that corresponds well to how darcs is behaving
-- even in complicated situations.

<P>
In a single darcs repository you can think of two ``versions'' of the source tree.
	They are called the <SPAN  CLASS="textit">working</SPAN> and <SPAN  CLASS="textit">pristine</SPAN> trees.
    <SPAN  CLASS="textit">Working</SPAN> is your normal source tree, with or without darcs alongside.
	The only thing that makes it part of a darcs repository
	is the <code>_darcs</code> directory in its root.
    <SPAN  CLASS="textit">Pristine</SPAN> is the recorded state of the source tree.
	The pristine tree is constructed from groups of changes,
        called <EM>patches</EM> (some other version control use the
	term <EM>changeset</EM> instead of <EM>patch</EM>).<A NAME="tex2html9"
  HREF="#foot2000"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A>	Darcs will create and store these patches
	based on the changes you make in <SPAN  CLASS="textit">working</SPAN>.

<P>

<H2><A NAME="SECTION00621000000000000000">
Changes</A>
</H2>
	If <SPAN  CLASS="textit">working</SPAN> and <SPAN  CLASS="textit">pristine</SPAN> are the same,
	there are ``no changes'' in the repository.
	Changes can be introduced (or removed) by editing the files in <SPAN  CLASS="textit">working</SPAN>.
	They can also be caused by darcs commands,
	which can modify <SPAN  CLASS="textit">both</SPAN> <SPAN  CLASS="textit">working</SPAN> and <SPAN  CLASS="textit">pristine</SPAN>.
	It is important to understand for each darcs command
	how it modifies <SPAN  CLASS="textit">working</SPAN>, <SPAN  CLASS="textit">pristine</SPAN> or both of them.

<P>
<code>whatsnew</code> (as well as <code>diff</code>) can show
	the difference between <SPAN  CLASS="textit">working</SPAN> and <SPAN  CLASS="textit">pristine</SPAN> to you.
	It will be shown as a difference in <SPAN  CLASS="textit">working</SPAN>.
	In advanced cases it need <SPAN  CLASS="textit">not</SPAN> be <SPAN  CLASS="textit">working</SPAN> that has changed;
	it can just as well have been <SPAN  CLASS="textit">pristine</SPAN>, or both.
	The important thing is the difference and what darcs can do with it.

<P>

<H2><A NAME="SECTION00622000000000000000">
Keeping or discarding changes</A>
</H2>
    If you have a difference in <SPAN  CLASS="textit">working</SPAN>, you do two things
    with it: <code>record</code> it to keep it, or <code>revert</code> it to lose the changes.<A NAME="tex2html10"
  HREF="#foot369"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A>
<P>
If you have a difference between <SPAN  CLASS="textit">working</SPAN> and <SPAN  CLASS="textit">pristine</SPAN>--for example after editing some files in <SPAN  CLASS="textit">working</SPAN>--<code>whatsnew</code> will show some ``unrecorded changes''.
	To save these changes, use <code>record</code>.
	It will create a new patch in <SPAN  CLASS="textit">pristine</SPAN> with the same changes,
	so <SPAN  CLASS="textit">working</SPAN> and <SPAN  CLASS="textit">pristine</SPAN> are no longer different.
	To instead undo the changes in <SPAN  CLASS="textit">working</SPAN>, use <code>revert</code>.
	It will modify the files in <SPAN  CLASS="textit">working</SPAN> to be the same as in <SPAN  CLASS="textit">pristine</SPAN>
	(where the changes do not exist).

<P>

<H2><A NAME="SECTION00623000000000000000">
Unrecording changes</A>
</H2>
    <code>unrecord</code> is a command meant to be run only in private
    repositories. Its intended purpose is to allow developers the flexibility
    to undo patches that haven't been distributed yet.

<P>
However, darcs does not prevent you from unrecording a patch that
    has been copied to another repository. Be aware of this danger!

<P>
If you <code>unrecord</code> a patch, that patch will be deleted from <SPAN  CLASS="textit">pristine</SPAN>.
	This will cause <SPAN  CLASS="textit">working</SPAN> to be different from <SPAN  CLASS="textit">pristine</SPAN>,
	and <code>whatsnew</code> to report unrecorded changes.
	The difference will be the same as just before that patch was <code>record</code>ed.
	Think about it.
	<code>record</code> examines what's different with <SPAN  CLASS="textit">working</SPAN>
	and constructs a patch with the same changes in <SPAN  CLASS="textit">pristine</SPAN>
	so they are no longer different.
	<code>unrecord</code> deletes this patch;
	the changes in <SPAN  CLASS="textit">pristine</SPAN> disappear and the difference is back.

<P>
If the recorded changes included an error,
	the resulting flawed patch can be unrecorded.
	When the changes have been fixed,
	they can be recorded again as a new--hopefully flawless--patch.

<P>
If the whole change was wrong it can be discarded from <SPAN  CLASS="textit">working</SPAN> too,
	with <code>revert</code>.
	<code>revert</code> will update <SPAN  CLASS="textit">working</SPAN> to the state of <SPAN  CLASS="textit">pristine</SPAN>,
	in which the changes do no longer exist after the patch was deleted.

<P>
Keep in mind that the patches are your history,
	so deleting them with <code>unrecord</code> makes it impossible to track
	what changes you <SPAN  CLASS="textit">really</SPAN> made.
	Redoing the patches is how you ``cover the tracks''.
	On the other hand,
	it can be a very convenient way to manage and organize changes
	while you try them out in your private repository.
	When all is ready for shipping,
	the changes can be reorganized in what seems as useful and impressive patches.
	Use it with care.

<P>
All patches are global,
	so don't <SPAN  CLASS="textit">ever</SPAN> replace an already ``shipped'' patch in this way!
	If an erroneous patch is deleted and replaced with a better one,
	you have to replace it in <SPAN  CLASS="textit">all</SPAN> repositories that have a copy of it.
	This may not be feasible, unless it's all private repositories.
	If other developers have already made patches or tags in their repositories
	that depend on the old patch, things will get complicated.

<P>

<H2><A NAME="SECTION00624000000000000000">
Special patches and pending</A>
</H2>

<P>
The patches described in the previous sections have mostly been hunks.
A <SPAN  CLASS="textit">hunk</SPAN> is one of darcs' primitive patch types,
and it is used to remove old lines and/or insert new lines.
There are other types of primitive patches,
such as <SPAN  CLASS="textit">adddir</SPAN> and <SPAN  CLASS="textit">addfile</SPAN>
which add new directories and files,
and <SPAN  CLASS="textit">replace</SPAN>
which does a search-and-replace on tokens in files.

<P>
Hunks are always calculated in place with a diff algorithm
just before <code>whatsnew</code> or <code>record</code>.
But other types of primitive patches need to be explicitly created
with a darcs command.
They are kept in <SPAN  CLASS="textit">pending</SPAN><A NAME="tex2html11"
  HREF="#foot2001"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN></SUP></A>until they are either recorded or reverted.

<P>
<SPAN  CLASS="textit">Pending</SPAN> can be thought of as a special extension of <SPAN  CLASS="textit">working</SPAN>.
When you issue, e.g., a darcs <code>replace</code> command,
the replace is performed on the files in <SPAN  CLASS="textit">working</SPAN>
and at the same time a replace patch is put in <SPAN  CLASS="textit">pending</SPAN>.
Patches in <SPAN  CLASS="textit">pending</SPAN> describe special changes made in <SPAN  CLASS="textit">working</SPAN>.
The diff algorithm will fictively apply these changes to <SPAN  CLASS="textit">pristine</SPAN>
before it compares it to <SPAN  CLASS="textit">working</SPAN>,
so all lines in <SPAN  CLASS="textit">working</SPAN> that are changed by a <code>replace</code> command
will also be changed in <SPAN  CLASS="textit">pending</SPAN><SPAN CLASS="MATH"><IMG
 WIDTH="31" HEIGHT="11" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg3.png"
 ALT="$+$"></SPAN><SPAN  CLASS="textit">pristine</SPAN>
when the hunks are calculated.
That's why no hunks with the replaced lines will be shown by <code>whatsnew</code>;
it only shows the replace patch in <SPAN  CLASS="textit">pending</SPAN> responsible for the change.

<P>
If a special patch is recorded, it will simply be moved to <SPAN  CLASS="textit">pristine</SPAN>.
If it is instead reverted, it will be deleted from <SPAN  CLASS="textit">pending</SPAN>
and the accompanying change will be removed from <SPAN  CLASS="textit">working</SPAN>.

<P>
Note that reverting a patch in pending is <SPAN  CLASS="textit">not</SPAN> the same as
simply removing it from pending.
It actually applies the inverse of the change to <SPAN  CLASS="textit">working</SPAN>.
Most notable is that reverting an addfile patch
will delete the file in <SPAN  CLASS="textit">working</SPAN> (the inverse of adding it).
So if you add the wrong file to darcs by mistake,
<SPAN  CLASS="textit">don't</SPAN> <code>revert</code> the addfile.
Instead first rename the file, revert, and then rename it back.

<P>

<H1><A NAME="SECTION00630000000000000000">
Using patches</A>
</H1> 
<P>
This section will lay down the concepts around patch distribution and branches.
The aim is to develop a way of thinking
that corresponds well to how darcs is behaving
-- even in complicated situations.

<P>
A repository is a collection of patches.
Patches have no defined order,
but patches can have dependencies on other patches.
Patches can be added to a repository in any order
as long as all depended upon patches are there.
Patches can be removed from a repository in any order,
as long as no remaining patches depend on them.

<P>
Repositories can be cloned to create branches.
Patches created in different branches may conflict.
A conflict is a valid state of a repository.
A conflict makes the working tree ambiguous until the conflict is resolved.

<P>

<H2><A NAME="SECTION00631000000000000000">
Dependencies</A>
</H2>

<P>
There are two kinds of dependencies:
implicit dependencies and explicit dependencies.

<P>
Implicit dependencies is the far most common kind.
These are calculated automatically by darcs.
If a patch removes a file or a line of code,
it will have to depend on the patch that added that file or line of code.<A NAME="tex2html12"
  HREF="#foot420"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN></SUP></A>If a patch adds a line of code,
it will usually have to depend on the patch or patches that added the adjacent lines.

<P>
Explicit dependencies can be created if you give the <code>--ask-deps</code> option to <code>darcs record</code>.
This is good for assuring that logical dependencies hold between patches.
It can also be used to group patches--a patch with explicit dependencies doesn't need to change anything--and pulling the patch also pulls all patches it was made to depend on.

<P>

<H2><A NAME="SECTION00632000000000000000">
Branches: just normal repositories</A>
</H2>

<P>
Darcs does not have branches--it doesn't need to.
Every repository can be used as a branch.
This means that any two repositories are ``branches'' in darcs,
but it is not of much use unless they have a large portion of patches in common.
If they are different projects they will have nothing in common,
but darcs may still very well be able to merge them,
although the result probably is nonsense.
Therefore the word ``branch'' isn't a technical term in darcs;
it's just the way we think of one repository in relation to another.

<P>
Branches are <SPAN  CLASS="textit">very</SPAN> useful in darcs.
They are in fact <SPAN  CLASS="textit">necessary</SPAN> if you want to do more than only simple work.
When you <code>get</code> someone's repository from the Internet,
you are actually creating a branch of it.
It may first seem inefficient (or if you come from CVS--frightening),
not to say plain awkward.
But darcs is designed this way, and it has means to make it efficient.
The answer to many questions about how to do a thing with darcs is: ``use a branch''.
It is a simple and elegant solution with great power and flexibility,
which contributes to darcs' uncomplicated user interface.

<P>
You create new branches (i.e., clone repositories)
with the <code>get</code> and <code>put</code> commands.

<P>

<H2><A NAME="SECTION00633000000000000000">
Moving patches around--no versions</A>
</H2>

<P>
Patches are global, and a copy of a patch either is or is not present in a branch.
This way you can rig a branch almost any way you like,
as long as dependencies are fulfilled--darcs <SPAN  CLASS="textit">won't</SPAN> let you break dependencies.
If you suspect a certain feature from some time ago introduced a bug,
you can remove the patch/patches that adds the feature,
and try without it.<A NAME="tex2html13"
  HREF="#foot2002"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN></SUP></A>
<P>
Patches are added to a repository with <code>pull</code>
and removed from the repositories with <code>unpull</code>.
Don't confuse these two commands with <code>record</code> and <code>unrecord</code>,
which constructs and deconstructs patches.

<P>
It is important not to lose patches when (re)moving them around.
<code>pull</code> needs a source repository to copy the patch from,
whereas <code>unpull</code> just erases the patch.
Beware that if you unpull <SPAN  CLASS="textit">all</SPAN> copies of a patch
it is completely lost--forever.
Therefore you should work with branches when you unpull patches.
The <code>unpull</code> command can wisely be disabled in a dedicated main repository
by adding <code>unpull disable</code> to the repository's defaults file.

<P>
For convenience, there is a <code>push</code> command.
It works like <code>pull</code> but in the other direction.
It also differs from <code>pull</code> in an important way:
it starts a second instance of darcs to apply the patch in the target repository,
even if it's on the same computer.
It can cause surprises if you have a ``wrong'' darcs in your PATH.

<P>

<H2><A NAME="SECTION00634000000000000000">
Tags--versions</A>
</H2>

<P>
While <code>pull</code> and <code>unpull</code> can be used to
construct different ``versions'' in a repository,
it is often desirable to name specific configurations of patches
so they can be identified and retrieved easily later.
This is how darcs implements what is usually known as versions.
The command for this is <code>tag</code>,
and it records a tag in the current repository.

<P>
A tag is just a patch, but it only contains explicit dependencies.
It will depend on all the patches in the current repository.<A NAME="tex2html14"
  HREF="#foot429"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN></SUP></A>Darcs can recognize if a patch is as a tag;
tags are sometimes treated specially by darcs commands.

<P>
While traditional revision control systems tag versions in the time line history,
darcs lets you tag any configuration of patches at any time,
and pass the tags around between branches.

<P>
With the option <code>--tag</code> to <code>get</code> you can easily get
a named version in the repository
as a new branch.

<P>

<H2><A NAME="SECTION00635000000000000000">
Conflicts</A>
</H2>

<P>
This part of darcs becomes a bit complicated,
and the description given here is slightly simplified.

<P>
Conflicting patches are created when
you record changes to the same line in two different repositories.
Same line does <SPAN  CLASS="textit">not</SPAN> mean the same line number and file name,
but the same line added by a common depended upon patch.

<P>
Contrary to many other merging tools,
darcs considers two patches making the <SPAN  CLASS="textit">same</SPAN> change to be a conflict.
In fact, darcs doesn't even look at the contents of the conflicting lines.
If you think this is wrong, think about two different patches
each adding a new keyword and also changing the line
``<code>#define NUM_OF_KEYWORDS 17</code>''
to
``<code>#define NUM_OF_KEYWORDS 18</code>''.

<P>
A conflict <SPAN  CLASS="textit">happens</SPAN> when two conflicting patches meet in the same repository.
This is no problem for darcs; it can happily pull together just any patches.
But it is a problem for the files in <SPAN  CLASS="textit">working</SPAN> (and <SPAN  CLASS="textit">pristine</SPAN>).
The conflict can be thought of as
two patches telling darcs different things about what a file should look like.

<P>
Darcs escapes this problem
by ignoring those parts<A NAME="tex2html15"
  HREF="#foot436"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN></SUP></A>of the patches that conflict.
They are ignored in <SPAN  CLASS="textit">both</SPAN> patches.
If patch&nbsp;A changes the line ``FIXME'' to ``FIXED'',
and patch&nbsp;B changes the same line to ``DONE'',
the two patches together will produce the line ``FIXME''.
Darcs doesn't care which one you pulled into the repository first,
you still get the same result when the conflicting patches meet.
All other changes made by A and B are performed as normal.

<P>
Darcs can mark a conflict for you in <SPAN  CLASS="textit">working</SPAN>.
This is done with <code>resolve</code> (which isn't a very good name).
Conflicts are marked such that both conflicting changes
are inserted with special delimiter lines around them.
Then you can merge the two changes by hand,
and remove the delimiters.

<P>
When you pull patches,
darcs automatically performs a <code>resolve</code> for you if a conflict happens.
You can remove the markup with <code>revert</code>,
Remember that the result will be the lines from
the previous version common to both conflicting patches.
The conflict marking can be redone again with <code>resolve</code>.

<P>
A special case is when a pulled patch conflicts with unrecorded changes in the repository.
The conflict will be automatically marked as usual,
but since the markup is <SPAN  CLASS="textit">also</SPAN> an unrecorded change,
it will get mixed in with your unrecorded changes.
There is no guarantee you can revert <code>only</code> the markup after this,
and <code>resolve</code> will not be able to redo this markup later if you remove it.
It is good practice to record important changes before pulling.

<P>
<code>resolve</code> can't mark complicated conflicts.
In that case you'll have to use <code>darcs diff</code> and other commands
to understand what the conflict is all about.
If for example two conflicting patches create the same file,
<code>resolve</code> will pick just one of them,
and no delimiters are inserted.
So watch out if darcs tells you about a conflict.

<P>
<code>resolve</code> can also be used to check for unresolved conflicts.
If there are none, darcs replies ``No conflicts to resolve''.
While <code>pull</code> reports when a conflict happens,
<code>unpull</code> and <code>get</code> don't.

<P>

<H2><A NAME="SECTION00636000000000000000">
Resolving conflicts</A>
</H2>

<P>
A conflict is resolved
(not marked, as with the command <code>resolve</code>)
as soon as some new patch depends on the conflicting patches.
This will usually be the resolve patch you record after manually putting together the pieces
from the conflict markup produced by <code>resolve</code> (or <code>pull</code>).
But it can just as well be a tag.
So don't forget to fix conflicts before you accidently ``resolve'' them by recording other patches.

<P>
If the conflict is with one of your not-yet-published patches,
you may choose to amend that patch rather than creating a resolve patch.

<P>
If you want to back out and wait with the conflict,
you can <code>unpull</code> the conflicting patch you just pulled.
Before you can do that you have to <code>revert</code> the conflict markups
that <code>pull</code> inserted when the conflict happened.

<P>

<H1><A NAME="SECTION00640000000000000000"></A>
<A NAME="darcs-development-practices"></A>
<BR>
Distributed development with one primary developer
</H1>

<P>
This is how darcs itself is developed.  There are many contributors to
darcs, but every contribution is reviewed and manually applied by myself.
For this sort of a situation, <code>darcs send</code> is ideal, since the barrier for
contributions is very low, which helps encourage contributors.

<P>
One could simply set the <code>_darcs/prefs/email</code> value to the project
mailing list, but I also use darcs send to send my changes to the main
server, so instead the email address is set to
``<code>Davids Darcs Repo &lt;droundy@abridgegame.org&gt;</code>''.  My .procmailrc
file on the server has the following rule:
<PRE>
:0:
* ^TODavids Darcs Repo
|(umask 022; darcs apply --reply darcs-devel@abridgegame.org \
             --repodir /path/to/repo --verify /path/to/allowed_keys)
</PRE>
This causes darcs apply to be run on any emails sent to ``Davids Darcs
Repo''.  Apply actually applies them only if they are signed by an
authorized key.  Currently, the only authorized key is mine, but of course
this could be extended easily enough.

<P>
The central darcs repository contains the following values in its
<code>_darcs/prefs/defaults</code>:
<PRE>
apply test
apply verbose
apply happy-forwarding
</PRE>
The first line tells apply to always run the test suite.  The test suite is
in fact the main reason I use send rather than push, since it allows me to
easily continue working (or put my computer to sleep) while the tests are
being run on the main server.  The second line is just there to improve the
email response that I get when a patch has either been applied or failed
the tests.  The third line makes darcs not complain about unsigned patches,
but just to forward them to <code>darcs-devel</code>.

<P>
On my development computer, I have in my <code>.muttrc</code> the following
alias, which allows me to easily apply patches that I get via email
directly to my darcs working directory:
<PRE>
macro pager A "&lt;pipe-entry&gt;(umask 022; darcs apply --no-test -v --repodir ~/darcs)"
</PRE>

<P>

<H1><A NAME="SECTION00650000000000000000"></A>
<A NAME="dft-development-practices"></A>
<BR>
Development by a small group of developers in one office
</H1>

<P>
This section describes the development method used for the density
functional theory code DFT++, which is available at
<code>http://dft.physics.cornell.edu/dft</code>.

<P>
We have a number of workstations which all mount the same <code>/home</code> via NFS.
We created a special ``dft'' user, with the central repository living in that
user's home directory.  The ssh public keys of authorized persons are added to
the ``dft'' user's <code>.ssh/allowed_keys</code>, and we commit patches to this
repository using darcs push.  As in Section&nbsp;<A HREF="#darcs-development-practices"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>,
we have the central repository set to run the test suite before the push goes
through.

<P>
Note that no one ever runs as the dft user.

<P>
A subtlety that we ran into showed up in the running of the test suite.
Since our test suite includes the running of MPI programs, it must be run
in a directory that is mounted across our cluster.  To achieve this, we set
the <code>$DARCS_TMPDIR</code> environment variable to <code>~/tmp</code>.

<P>
Note that even though there are only four active developers at the moment,
the distributed nature of darcs still plays a large role.  Each developer
works on a feature until it is stable, a process that often takes quite a
few patches, and only once it is stable pushes to the central repo.

<P>

<H1><A NAME="SECTION00700000000000000000">
Darcs commands</A>
</H1>

<P>
The general format of a darcs command is
<PRE>
% darcs COMMAND OPTIONS ARGUMENTS ...
</PRE>
Here <code>COMMAND</code> is a command such as <code>add</code> or <code>record</code>, which of
course may have one or more arguments.  Options have the form
<code>--option</code> or <code>-o</code>, while arguments vary from command to
command.  There are many options which are common to a number of different
commands, which will be summarized here.

<P>
If you wish, you may use any unambiguous beginning of a command name as a
shortcut: for <code>darcs record</code>, you could type <code>darcs recor</code> or
<code>darcs rec</code>, but not <code>darcs re</code> since that could be confused with
<code>darcs replace</code>, <code>darcs revert</code> and <code>darcs remove</code>.

<P>
In some cases, <code>COMMAND</code> actually consists of two words, a
super-command and a subcommand.  For example, the ``display the
manifest'' command has the form <code>darcs query manifest</code>.

<P>

<H4><A NAME="SECTION00700010000000000000">
Command overview</A>
</H4>

<P>
Not all commands modify the ``patches'' of your repository (that
is, the named patches which other users can pull); some commands only
affect the copy of the source tree you're working on (your ``working
directory''), and some affect both. This table summarizes what you should
expect from each one and will hopefully serve as guide when you're having
doubts about which command to use.

<P>
<DIV ALIGN="CENTER">

<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">affects</TD>
<TD ALIGN="CENTER">patches</TD>
<TD ALIGN="CENTER">working directory</TD>
</TR>
<TR><TD ALIGN="CENTER">record</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">no</TD>
</TR>
<TR><TD ALIGN="CENTER">unrecord</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">no</TD>
</TR>
<TR><TD ALIGN="CENTER">rollback</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">no</TD>
</TR>
<TR><TD ALIGN="CENTER">revert</TD>
<TD ALIGN="CENTER">no</TD>
<TD ALIGN="CENTER">yes</TD>
</TR>
<TR><TD ALIGN="CENTER">unrevert</TD>
<TD ALIGN="CENTER">no</TD>
<TD ALIGN="CENTER">yes</TD>
</TR>
<TR><TD ALIGN="CENTER">pull</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">yes</TD>
</TR>
<TR><TD ALIGN="CENTER">unpull</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">yes</TD>
</TR>
<TR><TD ALIGN="CENTER">apply</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">yes</TD>
</TR>
<TR><TD ALIGN="CENTER">push<A NAME="tex2html16"
  HREF="#foot461"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></TD>
<TD ALIGN="CENTER">no</TD>
<TD ALIGN="CENTER">no</TD>
</TR>
<TR><TD ALIGN="CENTER">send<A NAME="tex2html17"
  HREF="#foot462"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A></TD>
<TD ALIGN="CENTER">no</TD>
<TD ALIGN="CENTER">no</TD>
</TR>
<TR><TD ALIGN="CENTER">put<A NAME="tex2html18"
  HREF="#foot463"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN></SUP></A></TD>
<TD ALIGN="CENTER">no</TD>
<TD ALIGN="CENTER">no</TD>
</TR>
</TABLE>
</DIV>

<P>

<H1><A NAME="SECTION00710000000000000000">
Common options to darcs commands</A>
</H1>

<P>

<div class="cmd-opt-hdr">
--help
</div>
Every <code>COMMAND</code> accepts <code>--help</code> as an argument, which tells it to
provide a bit of help.  Among other things, this help always provides an
accurate listing of the options available with that command, and is
guaranteed never to be out of sync with the version of darcs you actually
have installed (unlike this manual, which could be for an entirely
different version of darcs).
<PRE>
% darcs COMMAND --help
</PRE>

<P>

<div class="cmd-opt-hdr">
--disable
</div>
Every <TT>COMMAND</TT> accepts the <code>--disable</code> option, which can be used in
<code>_darcs/prefs/defaults</code> to disable some commands in the repository. This
can be helpful if you want to protect the repository from accidental use of
advanced commands like unpull, unrecord or amend-record.

<P>

<div class="cmd-opt-hdr">
--verbose
</div>
Most commands also accept the <code>--verbose</code> option, which tells darcs to
provide additional output.  The amount of verbosity varies from command to
command.

<P>

<div class="cmd-opt-hdr">
--repodir
</div>
Another common option is the <code>--repodir</code> option, which allows you to
specify the directory of the repository in which to perform the command.
This option is used with commands, such as whatsnew, that ordinarily would
be performed within a repository directory, and allows you to use those
commands without actually being in the repo directory when calling the
command.  This is useful when running darcs as a pipe, as might be the case
when running apply from a mailer.

<P>

<H4><A NAME="SECTION00710010000000000000"></A><A NAME="selecting"></A>
<BR>
Selecting patches
</H4>

<P>
Many commands operate on a patch or patches that have already been recorded.
There are a number of options that specify which patches are selected for
these operations: <code>--patch</code>, <code>--match</code>, <code>--tag</code>, and variants
on these, which for <code>--patch</code> are <code>--patches</code>,
<code>--from-patch</code>, and <code>--to-patch</code>.  The <code>--patch</code> and
<code>--tag</code> forms simply take (POSIX extended, aka <code>egrep</code>) regular
expressions and match them against tag and patch names.  <code>--match</code>,
described below, allows more powerful patterns.

<P>
The plural forms of these options select all matching patches.  The singular
forms select the last matching patch.  The range (from and to) forms select
patches after or up to (both inclusive) the last matching patch.

<P>
These options use the current order of patches in the repository.  darcs may
reorder patches, so this is not necessarily the order of creation or the
order in which patches were applied.  However, as long as you are just
recording patches in your own repository, they will remain in order.

<P>

<H4><A NAME="SECTION00710020000000000000">
Match</A>
</H4>

<P>
Currently <code>--match</code> accepts five primitive match types, although
there are plans to expand it to match more patterns.  Also, note that the
syntax is still preliminary and subject to change.

<P>
The first match type accepts a literal string which is checked against
the patch name.  The syntax is
<PRE>
darcs annotate --summary --match 'exact foo+bar'
</PRE>
This is useful for situations where a patch name contains characters that
could be considered special for regular expressions.

<P>
The second match type accepts a regular expression which is checked against
the patch name.  The syntax is
<PRE>
darcs annotate --summary --match 'name foo'
</PRE>
If you want to include spaces in the regular expression, it must be
enclosed in double quotes (<code>"</code>), and currently there is no provision for
escaping a double quote, so you have to choose between matching double
quotes and matching spaces.

<P>
The third match type matches the darcs hash for each patch:
<PRE>
darcs annotate --summary --match \
  'hash 20040403105958-53a90-c719567e92c3b0ab9eddd5290b705712b8b918ef'
</PRE>
This is intended to be used, for example, by programs allowing you to view
darcs repositories (e.g. CGI scripts like viewCVS).

<P>
The fourth match type accepts a regular expression which is checked against
the patch author.  The syntax is
<PRE>
darcs annotate --summary --match 'author foo'
</PRE>

<P>
There is also now rudimentary support for matching by date.  This is done
using commands such as
<PRE>
darcs annotate --summary --match 'date "last week"'
darcs annotate --summary --match 'date yesterday'
darcs annotate --summary --match 'date today'
darcs changes --from-match 'date "Sat Jun  30 11:31:30 EDT 2004"'
</PRE>
currently date matching always matches only the day itself.  FIXME: It
should be extended to match the time as well if the time is specified.  In
general, a lot of cleanup is needed in the date matching code.

<P>
Because the date matching is only by day, you may prefer to combine it with
a more specific pattern.
<PRE>
darcs annotate --summary --match 'date "last week" &amp;&amp; name foo'
</PRE>

<P>
The <code>--match</code> pattern can include the logical operators <code>&amp;&amp;</code>,
<code>||</code> and <code>not</code>, as well as grouping of patterns with parentheses.
For example
<PRE>
darcs annotate --summary --match 'name record &amp;&amp; not name overrode'
</PRE>

<P>

<div class="cmd-opt-hdr">
--ignore-times
</div>
Darcs optimizes its operations by keeping track of the modification times
of your files.  This dramatically speeds up commands such as
<code>whatsnew</code> and <code>record</code> which would otherwise require reading
every file in the repo and comparing it with a reference version.  However,
there are times when this can cause problems, such as when running a series
of darcs commands from a script, in which case often a file will be
modified twice in the same second, which can lead to the second
modification going unnoticed.  The solution to such predicaments is the
<code>--ignore-times</code> option, which instructs darcs not to trust the file
modification times, but instead to check each file's contents explicitly.

<P>

<div class="cmd-opt-hdr">
--author
</div>
Several commands need to be able to identify you.  Conventionally, you
provide an email address for this purpose, which can include comments,
e.g. <code>David Roundy &lt;droundy@abridgegame.org&gt;</code>.  The easiest way to do
this is
to define an environment variable <code>EMAIL</code> or <code>DARCS_EMAIL</code> (with
the latter overriding the former).  You can also override this using the
<code>--author</code> flag to any command.  Alternatively, you could set your
email address on a per-repository basis using the ``defaults'' mechanism
for ``ALL'' commands, as described in Appendix&nbsp;<A HREF="#repository_format"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.
Or, you could specify the author on a per-repository basis using the
<code>_darcs/prefs/author</code> file as described in section&nbsp;<A HREF="#author_prefs"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.

<P>
Also, a global author file can be created in your home directory with the name
<code>.darcs/author</code>.  This file overrides the
contents of the environment variables, but a repository-specific author
file overrides the global author file.

<P>

<div class="cmd-opt-hdr">
--dont-compress, --compress
</div>
By default, darcs commands that write patches to disk will compress the
patch files.  If you don't want this, you can choose the
<code>--dont-compress</code> option, which causes darcs not to compress the patch
file.

<P>

<div class="cmd-opt-hdr">
--gui
</div>
Certain commands may have an optional graphical user interface.  If such
commands are supported, you can activate the graphical user interface by
calling darcs with the <code>--gui</code> flag.

<P>
NOTE: The GUI is not currently functional, but is expected to re-appear 
in a future release. 

<P>

<div class="cmd-opt-hdr">
--dry-run
</div>
The <code>--dry-run</code> option will cause darcs not to actually take the specified
action, but only print what would have happened.  Not all commands accept
<code>--dry-run</code>, but those that do should accept the <code>--summary</code>  option.

<P>

<div class="cmd-opt-hdr">
--summary, --no-summary
</div>
The <code>--summary</code> option shows a summary of the patches that would have been
pulled/pushed/whatever. The format is similar to the output format of
<code>cvs update</code> and looks like this:

<P>
<PRE>
A  ./added_but_not_recorded.c
A! ./added_but_not_recorded_conflicts.c
a  ./would_be_added_if_look_for_adds_option_was_used.h

M  ./modified.t -1 +1
M! ./modified_conflicts.t -1 +1

R  ./removed_but_not_recorded.c
R! ./removed_but_not_recorded_conflicts.c
</PRE>

<P>
You can probably guess what the flags mean from the clever file names.
<DL>
<DT></DT>
<DD><TT>A</TT> is for files that have been added but not recorded yet.
</DD>
<DT></DT>
<DD><TT>a</TT> is for files found using the <code>--look-for-adds</code> option available for
<code>whatsnew</code> and <code>record</code>. They have not been added yet, but would be
added automatically if <code>--look-for-adds</code> were used with the next
<code>record</code> command.

<P>
</DD>
<DT></DT>
<DD><TT>M</TT> is for files that have been modified in the working directory but not
recorded yet. The number of added and subtracted lines is also shown.

<P>
</DD>
<DT></DT>
<DD><TT>R</TT>  is for files that have been removed, but the removal is not
recorded yet.
</DD>
</DL>
An exclamation mark appears next to any option that has a conflict.

<P>

<H4><A NAME="SECTION00710030000000000000"></A><A NAME="resolution"></A>
<BR>
Resolution of conflicts
</H4>

<P>
To resolve conflicts using an external tool, you need to specify a command
to use, e.g.
<PRE>
--external-merge 'opendiff %1 %2 -ancestor %a -merge %o'.
</PRE>
The <code>%1</code> and <code>%2</code>  are replaced with the two versions to be
merged, <code>%a</code> is replaced with the common ancestor of the two versions.
Most importantly, <code>%o</code> is replaced with the name of the output file
that darcs will require to be created holding the merged version.  The
above example works with the FileMerge.app tool that comes with Apple's
developer tools.  To use xxdiff, you would use
<PRE>
--external-merge 'xxdiff -m -O -M %o %1 %a %2'
</PRE>
To use <code>kdiff3</code>, you can use
<PRE>
--external-merge 'kdiff3 --output %o %a %1 %2'
</PRE>

<P>
Note that the command is split into space-separated words and the first one is
<code>exec</code>ed with the rest as arguments--it is not a shell command.  Also
the substitution of the <code>%</code> escapes is only done on complete words.
This means that to use Emacs' Ediff package for merging, for example, you need
a helper script as follows; call it <code>emerge3</code>, say:<PRE>
 #! /bin/sh
 # External merge command for darcs, using Emacs Ediff, via server if possible.
 # It needs args %1 %2 %a %o, i.e. the external merge command is, say,
 # `emerge3 %1 %2 %a %o'.
 test $# -eq 4 || exit 1
 form="(ediff-merge-files-with-ancestor"
 while test $# -gt 0; do
     count=$count.
     if [ $count = .... ]; then
         form=$form\ nil         # Lisp STARTUP-HOOKS arg
     fi
     case $1 in                  # Worry about quoting -- escape " and \
         *[\"\\]* ) form=$form\ \"$(echo $1 | sed -e's/["\\]/\\\0/g')\" ;;
         *) form=$form\ \"$1\" ;;
     esac
     shift
 done
 form=$form')'
 ( emacsclient --eval "$form" || # Emacs 22 server
   gnudoit "$form" ||            # XEmacs/Emacs 21 server
   emacs --eval "$form" ||       # Relatively slow to start up
   xemacs -eval "$form"          # Horribly slow to start up
 ) 2&gt;/dev/null
</PRE>
It would be invoked like:
<PRE>
--external-merge 'emerge3 %1 %2 %a %o'
</PRE>

<P>
If you figure out how to use darcs with another merge tool, please let me
know what flags you used so I can mention it here.

<P>
Note that if you do use an external merge tool, most likely you will want
to add to your defaults file
(<code>_darcs/prefs/defaults</code> or <code>~/.darcs/prefs</code>, see <A HREF="#defaults"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>)
a line such as
<PRE>
ALL external-merge kdiff3 --output %o %a %1 %2
</PRE>
Note that the defaults file does not want quotes around the command.

<P>

<div class="cmd-opt-hdr">
--posthook=COMMAND, --no-posthook
</div>
To provide a command that should be run whenever a darcs command completes
successfully, use <code>--posthook</code> to specify the command.  This is useful
for people who want to have a command run whenever a patch is applied.  Using
<code>--no-posthook</code> will disable running the command.  

<div class="cmd-opt-hdr">
--prompt-posthook, --run-posthook
</div>
These options control prompting before running the posthook.  Use
<code>--prompt-posthook</code> to force prompting before running the
posthook command.  For security reasons, this is the default.  When
defining a posthook for apply, you will need to use
<code>--run-posthook</code> or else you will get an error, because the
subprocess which runs the apply command cannot prompt the user.

<P>

<H1><A NAME="SECTION00720000000000000000">
Options apart from darcs commands</A>
</H1>

<div class="cmd-opt-hdr">
--help, --extended-help
</div>
Calling darcs with just <code>--help</code> as an argument gives a brief
summary of what commands are available.
The <code>--extended-help</code> option gives a more technical summary of
what the commands actually <SPAN  CLASS="textit">do</SPAN>.

<div class="cmd-opt-hdr">
--version, --exact-version
</div>
Calling darcs with the flag <code>--version</code> tells you the version of
darcs you are using.  Calling darcs with the flag <code>--exact-version</code>
gives the precise version of darcs, even if that version doesn't correspond
to a released version number.  This is helpful with bug reports, especially
when running with a ``latest'' version of darcs.

<div class="cmd-opt-hdr">
--commands
</div>
Similarly calling darcs with only <code>--commands</code> gives a simple list
of available commands.  This latter arrangement is primarily intended for
the use of command-line autocompletion facilities, as are available in
bash.

<P>

<H1><A NAME="SECTION00730000000000000000">
Creating repositories</A>
</H1>

<P>

<H2><A NAME="SECTION00731000000000000000">
darcs initialize</A>
</H2>

<P>
<code>Usage: darcs initialize [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--plain-pristine-tree</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Use a plain pristine tree [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-pristine-tree</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Use no pristine tree</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Initialize a new source tree as a darcs repository.

<P>
Generally you will only call initialize once for each project you work on,
and calling it is just about the first thing you do.  Just make sure you
are in the main directory of the project, and initialize will set up all the
directories and files darcs needs in order to start keeping track of
revisions for your project.

<P>
The <code>initialize</code> command actually follows a very simple procedure.
It creates the directories <code>_darcs</code>, <code>_darcs/current</code> (or
<code>_darcs/pristine</code>) and <code>_darcs/patches</code>, and then creates an
empty file, <code>_darcs/inventory</code>.  However, it is strongly
recommended that you use <code>darcs initialize</code> to do this, as this
procedure may change in a future version of darcs.

<P>

<div class="cmd-opt-hdr">
--no-pristine-tree
</div>
In order to save disk space, you can use <code>initialize</code> with the
<code>--no-pristine-tree</code> flag to create a repository with no pristine
tree.  Please see Section&nbsp;<A HREF="#disk-usage"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A> for more information.

<P>

<H2><A NAME="SECTION00732000000000000000">
darcs get</A>
</H2>

<P>
<code>Usage: darcs get [OPTION]... &lt;REPOSITORY&gt; [&lt;DIRECTORY&gt;]</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repo-name DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

path of output directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--partial</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

get partial repository using checkpoint</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--complete</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

get a complete copy of the repository</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--context FILENAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

version specified by the context in FILENAME</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--set-default</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

set default repository [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-set-default</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't set default repository</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--set-scripts-executable</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

make scripts executable</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-set-scripts-executable</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't make scripts executable</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--plain-pristine-tree</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Use a plain pristine tree [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-pristine-tree</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Use no pristine tree</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
If the remote repo and the current directory are in the same filesystem and
that filesystem supports hard links, get will create hard links for the
patch files, which means that the additional storage space needed will be
minimal.  This is <SPAN  CLASS="textit">very</SPAN> good for your disk usage (and for the speed
of running get), so if you want multiple copies of a repository, I strongly
recommend first running <code>darcs get</code> to get yourself one copy, and then
running <code>darcs get</code> on that copy to make any more you like.  The only
catch is that the first time you run <code>darcs push</code> or <code>darcs pull</code>
from any of these second copies, by default they will access your first
copy--which may not be what you want.

<P>
You may specify the name of the repository created by providing a second
argument to get, which is a directory name.

<P>

<div class="cmd-opt-hdr">
--context, --tag, --to-patch, --to-match
</div>
If you want to get a specific version of a repository, you have a few
options.  You can either use the <code>--tag</code>, <code>--to-patch</code> or
<code>--to-match</code> options, or you can use the <code>--context=FILENAME</code>
option, which specifies a file containing a context generated with
<code>darcs changes --context</code>.  This allows you (for example) to include in
your compiled program an option to output the precise version of the
repository from which it was generated, and then perhaps ask users to
include this information in bug reports.

<P>
Note that when specifying <code>--to-patch</code> or <code>--to-match</code>, you may
get a version of your code that has never before been seen, if the patches
have gotten themselves reordered.  If you ever want to be able to precisely
reproduce a given version, you need either to tag it or create a context
file.

<P>

<div class="cmd-opt-hdr">
--partial
</div>
Only get the patches since the last checkpoint. This will save time, 
bandwidth and disk space, at the expense of losing the history before 
the checkpoint. 

<P>

<div class="cmd-opt-hdr">
--no-pristine-tree
</div>
In order to save disk space, you can use <TT>get</TT> with the
<code>--no-pristine-tree</code> flag to create a repository with no pristine
tree.  Please see Section&nbsp;<A HREF="#disk-usage"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A> for more information.

<P>

<H2><A NAME="SECTION00733000000000000000">
darcs put</A>
</H2>
<code>Usage: darcs put [OPTION]... &lt;NEW REPOSITORY&gt;</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--context FILENAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

version specified by the context in FILENAME</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--apply-as USERNAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

apply patch as another user using sudo</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--apply-as-myself</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't use sudo to apply as another user [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--plain-pristine-tree</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Use a plain pristine tree [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-pristine-tree</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Use no pristine tree</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Put is the opposite of get. Put copies the content of the current 
repository and puts it in a newly created repository.

<P>
<SPAN  CLASS="textit">WARNING:</SPAN> Put is far less optimized than get, especially for local
repositories.  We recommend avoiding use of put except for small
repositories.

<P>
Put is used when you already have a repository and want to make a copy
of it.  A typical use-case is when you want to branch your project.

<P>
Put works by first initializing a repository. If the new repository is
not on the local file system then darcs will login to the remote host
and run <code>darcs init</code> there. After the new repository is created
all selected patches will be pushed just as with the command
<code>push</code>.

<P>

<div class="cmd-opt-hdr">
--apply-as
</div>

<P>
If you give the <code>--apply-as</code> flag, darcs will use sudo to apply the
changes as a different user.  This can be useful if you want to set up a
system where several users can modify the same repository, but you don't
want to allow them full write access.  This isn't secure against skilled
malicious attackers, but at least can protect your repository from clumsy,
inept or lazy users.

<P>

<div class="cmd-opt-hdr">
--context, --tag, --to-patch, --to-match
</div>
If you want to put a specific version of a repository, you have a few
options.  You can either use the <code>--tag</code>, <code>--to-patch</code> or
<code>--to-match</code> options, or you can use the <code>--context=FILENAME</code>
option, which specifies a file containing a context generated with
<code>darcs changes --context</code>.  This allows you (for example) to include in
your compiled program an option to output the precise version of the
repository from which it was generated, and then perhaps ask users to
include this information in bug reports.

<P>
Note that when specifying <code>--to-patch</code> or <code>--to-match</code>, you may
get a version of your code that has never before been seen, if the patches
have gotten themselves reordered.  If you ever want to be able to precisely
reproduce a given version, you need either to tag it or create a context
file.

<P>

<H1><A NAME="SECTION00740000000000000000">
Modifying the contents of a repo</A>
</H1>

<P>

<H2><A NAME="SECTION00741000000000000000">
darcs add</A>
</H2>

<P>
<code>Usage: darcs add [OPTION]... &lt;FILE or DIRECTORY&gt; ...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--boring</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't skip boring files</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--case-ok</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't refuse to add files differing only in case</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-r</code></TD>
<TD ALIGN="LEFT"><code>--recursive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

add contents of subdirectories</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--not-recursive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't add contents of subdirectories</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--date-trick</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

add files with date appended to avoid conflict. [EXPERIMENTAL] </TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-date-trick</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't use experimental date appending trick. [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dry-run</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't actually take the action</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Add needs to be called whenever you add a new file or directory to your
project.  Of course, it also needs to be called when you first create the
project, to let darcs know which files should be kept track of.

<P>
Darcs will refuse to add a file or directory that differs from an existing
one only in case.  This is because the HFS+ file system used on MacOS
treats such files as being one and the same.

<P>
You can not add symbolic links to darcs.
If you try to do that, darcs will refuse and print an error message.
Perhaps you want to make symbolic links <SPAN  CLASS="textit">to</SPAN> the files in darcs instead?

<P>

<div class="cmd-opt-hdr">
--boring
</div>

<P>
By default darcs will ignore all files that match any of the boring patterns.
If you want to add such a file anyway you must use the <code>--boring</code> option.

<P>

<div class="cmd-opt-hdr">
--date-trick
</div>

<P>
The <code>--date-trick</code> option allows you to enable an experimental trick
to make add conflicts, in which two users each add a file or directory with
the same name, less problematic.  While this trick is completely safe, it
is not clear to what extent it is beneficial.

<P>

<H2><A NAME="SECTION00742000000000000000">
darcs remove</A>
</H2>

<P>
<code>Usage: darcs remove [OPTION]... &lt;FILE or DIRECTORY&gt; ...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Remove should be called when you want to remove a file from your project,
but don't actually want to delete the file.  Otherwise just delete the
file or directory, and darcs will notice that it has been removed.
Be aware that the file WILL be deleted from any other copy of the repo
to which you later apply the patch.

<P>

<H2><A NAME="SECTION00743000000000000000">
darcs mv</A>
</H2>

<P>
<code>Usage: darcs mv [OPTION]... [FILE or DIRECTORY]...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--case-ok</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't refuse to add files differing only in case</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Darcs mv needs to be called whenever you want to move files or
directories. Unlike remove, mv actually performs the move itself in your
working copy.
 This is why ``mv'' isn't called ``move'', since it is
really almost equivalent to the unix command ``mv''.  I could add an
equivalent command named ``move'' for those who like vowels.

<P>

<div class="cmd-opt-hdr">
--case-ok
</div>

<P>
Darcs mv will by default refuse to rename a file if there already exists a
file having the same name apart from case.  This is because doing so could
create a repository that could not be used on file systems that are case
insensitive (such as Apples HFS+).  You can override this by with the flag
<code>--case-ok</code>.

<P>

<H2><A NAME="SECTION00744000000000000000">
darcs replace</A>
</H2>

<P>
<code>Usage: darcs replace [OPTION]... &lt;OLD&gt; &lt;NEW&gt; &lt;FILE&gt; ...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--token-chars "[CHARS]"</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

define token to contain these characters</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--force</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

proceed with replace even if 'new' token already exists</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-force</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't force the replace if it looks scary</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Replace allows you to change a specified token wherever it
occurs in the specified files.  The replace is encoded in a
special patch and will merge as expected with other patches.
Tokens here are defined by a regexp specifying the characters
which are allowed.  By default a token corresponds to a C identifier.

<P>
The default regexp is <code>[A-Za-z_0-9]</code>), and if one of your tokens
contains a `<code>-</code>' or `<code>.</code>', you will then (by default) get the ``filename''
regexp, which is <code>[A-Za-z_0-9\-\.]</code>.

<P>

<div class="cmd-opt-hdr">
--token-chars
</div>

<P>
If you prefer to choose a different set of characters to define your token
(perhaps because you are programming in some other language), you may do so
with the <code>--token-chars</code> option.  You may prefer to define tokens in terms
of delimiting characters instead of allowed characters using a flag such as
<code>--token-chars '[^ \n\t]'</code>, which would define a token as being
white-space delimited.

<P>
If you do choose a non-default token definition, I recommend using
<code>_darcs/prefs/defaults</code> to always specify the same
<code>--token-chars</code>, since your replace patches will be better behaved (in
terms of commutation and merges) if they have tokens defined in the same
way.

<P>
When using darcs replace, the ``new'' token may not already appear in the
file--if that is the case, the replace change would not be invertible.
This limitation holds only on the already-recorded version of the file.

<P>
There is a potentially confusing difference, however, when a replace is
used to make another replace possible:
<PRE>
% darcs replace newtoken aaack ./foo.c
% darcs replace oldtoken newtoken ./foo.c
% darcs record
</PRE>
will be valid, even if <code>newtoken</code> and <code>oldtoken</code> are both present
in the recorded version of foo.c, while the sequence
<PRE>
% [manually edit foo.c replacing newtoken with aaack]
% darcs replace oldtoken newtoken ./foo.c
</PRE>
will fail because ``newtoken'' still exists in the recorded version of
<code>foo.c</code>.  The reason for the difference is that when recording, a
``replace'' patch always is recorded <SPAN  CLASS="textit">before</SPAN> any manual changes,
which is usually what you want, since often you will introduce new
occurrences of the ``newtoken'' in your manual changes.  In contrast,
multiple ``replace'' changes are recorded in the order in which
they were made.

<P>

<H1><A NAME="SECTION00750000000000000000">
Working with changes</A>
</H1>

<P>

<H2><A NAME="SECTION00751000000000000000">
darcs record</A>
</H2>

<P>
<code>Usage: darcs record [OPTION]... [FILE or DIRECTORY]...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-m</code></TD>
<TD ALIGN="LEFT"><code>--patch-name PATCHNAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

name of patch</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-A</code></TD>
<TD ALIGN="LEFT"><code>--author EMAIL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify author id</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--logfile FILE</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give patch name and comment in file</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--delete-logfile</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

delete the logfile when done</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--leave-test-directory</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't remove the test directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--remove-test-directory</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

remove the test directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-a</code></TD>
<TD ALIGN="LEFT"><code>--all</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

answer yes to all patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--pipe</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

expect to receive input from a pipe</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ask-deps</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

ask for extra dependencies</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-ask-deps</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't ask for extra dependencies</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--edit-long-comment</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Edit the long comment by default</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--skip-long-comment</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Don't give a long comment</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--prompt-long-comment</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Prompt for whether to edit the long comment</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-l</code></TD>
<TD ALIGN="LEFT"><code>--look-for-adds</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

In addition to modifications, look for files that are not boring, and thus are potentially pending addition</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-look-for-adds</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Don't look for any files or directories that could be added, and don't add them automatically</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
If you provide one or more files or directories as additional arguments
to record, you will only be prompted to changes in those files or
directories.
Each patch is given a name, which typically would consist of a brief
description of the changes.  This name is later used to describe the patch.
The name must fit on one line (i.e. cannot have any embedded newlines).  If
you have more to say, stick it in the log.
The patch is also flagged with the author of the change, taken by default
from the <code>DARCS_EMAIL</code> environment variable, and if that doesn't
exist, from the <code>EMAIL</code> environment variable.  The date on which the
patch was recorded is also included.  Currently there is no provision for
keeping track of when a patch enters a given repository.
Finally, each changeset should have a full log (which may be empty).  This
log is for detailed notes which are too lengthy to fit in the name.  If you
answer that you do want to create a comment file, darcs will open an editor
so that you can enter the comment in.  The choice of editor proceeds as
follows.  If one of the <code>$DARCS_EDITOR</code>, <code>$VISUAL</code> or
<code>$EDITOR</code> environment variables is defined, its value is used (with
precedence proceeding in the order listed).  If not, ``vi'', ``emacs'',
``emacs&nbsp;-nw'' and ``nano'' are tried in that order.

<P>

<div class="cmd-opt-hdr">
--logfile
</div>

<P>
If you wish, you may specify the patch name and log using the
<code>--logfile</code> flag.  If you do so, the first line of the specified file
will be taken to be the patch name, and the remainder will be the ``long
comment''.  This feature can be especially handy if you have a test that
fails several times on the record (thus aborting the record), so you don't
have to type in the long comment multiple times. The file's contents will
override the <code>--patch-name</code> option.

<P>

<div class="cmd-opt-hdr">
--ask-deps
</div>

<P>
Each patch may depend on any number of previous patches.  If you choose to
make your patch depend on a previous patch, that patch is required to be
applied before your patch can be applied to a repo.  This can be used, for
example, if a piece of code requires a function to be defined, which was
defined in an earlier patch.

<P>
If you want to manually define any dependencies for your patch, you can use
the <code>--ask-deps</code> flag, and darcs will ask you for the patch's
dependencies.

<P>

<div class="cmd-opt-hdr">
--no-test,  --test
</div>

<P>
If you configure darcs to run a test suite, darcs will run this test on the
recorded repo to make sure it is valid.  Darcs first creates a pristine
copy of the source tree (in a temporary directory), then it runs the test,
using its return value to decide if the record is valid.  If it is not valid,
the record will be aborted.  This is a handy way to avoid making stupid
mistakes like forgetting to `darcs add' a new file.  It also can be
tediously slow, so there is an option (<code>--no-test</code>) to skip the test.

<P>

<div class="cmd-opt-hdr">
--pipe
</div>

<P>
If you run record with the <code>--pipe</code> option, you will be prompted for
the patch name, patch date and the long comment.  The long comment will
extend until the end of file of stdin is reached (ctrl-D on Unixy systems).
This interface is intended for scripting darcs, in particular for writing
repository conversion scripts.  The prompts are intended mostly as a useful
guide (since scripts won't need them), to help you understand the format in
which to provide the input.

<P>

<div class="cmd-opt-hdr">
--interactive
</div>

<P>
By default, <code>record</code> works interactively. Probably the only thing you need
to know about using this is that you can press <code>?</code> at the prompt to be
shown a list of the rest of the options and what they do. The rest should be
clear from there. Here's a
``screenshot'' to demonstrate:

<P>
<PRE>
hunk ./hello.pl +2
+#!/usr/bin/perl
+print "Hello World!\n";
Shall I record this patch? (2/2) [ynWsfqadjk], or ? for help: ?
How to use record...
y: record this patch
n: don't record it
w: wait and decide later, defaulting to no

s: don't record the rest of the changes to this file
f: record the rest of the changes to this file

d: record selected patches
a: record all the remaining patches
q: cancel record

j: skip to next patch
k: back up to previous patch
h or ?: show this help

&lt;Space&gt;: accept the current default (which is capitalized)
</PRE>
What you can't see in that ``screenshot'' is that <code>darcs</code> will also try to use
color in your terminal to make the output even easier to read.

<P>

<H2><A NAME="SECTION00752000000000000000">
darcs pull</A>
</H2>

<P>
<code>Usage: darcs pull [OPTION]... [REPOSITORY]</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--matches PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patches REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tags REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tags matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-a</code></TD>
<TD ALIGN="LEFT"><code>--all</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

answer yes to all patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--external-merge COMMAND</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Use external tool to merge conflicts</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dry-run</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't actually take the action</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-s</code></TD>
<TD ALIGN="LEFT"><code>--summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-deps</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't automatically fulfill dependencies</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--set-default</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

set default repository [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-set-default</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't set default repository</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--set-scripts-executable</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

make scripts executable</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-set-scripts-executable</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't make scripts executable</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Pull is used to bring changes made in another repo into the current repo
(that is, either the one in the current directory, or the one specified with
the -repodir option). Pull allows you to bring over all or some of the
patches that are in that repo but not in this one. Pull accepts an argument,
which is the URL from which to pull, and when called without an argument,
pull will use the repository from which you have most recently either pushed
or pulled.

<P>

<div class="cmd-opt-hdr">
--external-merge
</div>

<P>
You can use an external interactive merge tool to resolve conflicts with the
flag <code>--external-merge</code>.  For more details see
subsection&nbsp;<A HREF="#resolution"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.

<P>

<div class="cmd-opt-hdr">
--matches, --no-deps, --patches, --tags
</div>

<P>
The <code>--patches</code>, <code>--matches</code>, and <code>--tags</code> options can be
used to select which patches to pull, as described in
subsection&nbsp;<A HREF="#selecting"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.  darcs will silently pull along any other patches
upon which the selected patches depend.  So <code>--patches bugfix</code> means
``pull all the patches with `bugfix' in their name, along with any patches
they require.''  If you really only want the patches with `bugfix' in their
name, you should use the <code>--no-deps</code> option, which makes darcs pull in
only the selected patches which have no dependencies (apart from other
selected patches).

<P>

<div class="cmd-opt-hdr">
--no-test, --test
</div>

<P>
If you specify the <code>--test</code> option, pull will run the test (if a test
exists) on a scratch copy of the repo contents prior to actually performing
the pull.  If the test fails, the pull will be aborted.

<P>

<div class="cmd-opt-hdr">
--verbose
</div>

<P>
Adding the <code>--verbose</code> option causes another section to appear in the
output which also displays a summary of patches that you have and the remote
repo lacks. Thus, the following syntax can be used to show you all the patch
differences between two repos:

<P>
<PRE>
darcs pull --dry-run --verbose
</PRE>

<P>

<H2><A NAME="SECTION00753000000000000000">
darcs push</A>
</H2>

<P>
<code>Usage: darcs push [OPTION]... [REPOSITORY]</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--matches PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patches REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tags REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tags matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-a</code></TD>
<TD ALIGN="LEFT"><code>--all</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

answer yes to all patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--apply-as USERNAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

apply patch as another user using sudo</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--apply-as-myself</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't use sudo to apply as another user [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dry-run</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't actually take the action</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-s</code></TD>
<TD ALIGN="LEFT"><code>--summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--set-default</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

set default repository [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-set-default</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't set default repository</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Push is the opposite of pull.  Push allows you to copy changes from the
current repository into another repository.

<P>
For obvious reasons, you can only push to repositories to which you have
write access.  In addition, you can only push to repos that you access
either on the local file system or with ssh.  In order to apply with ssh,
darcs must also be installed on the remote computer.  The command invoked
to run ssh may be configured by the <code>DARCS_SSH</code> environment variable
(see subsection&nbsp;<A HREF="#darcsssh"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>).  The command invoked via ssh is always
<code>darcs</code>, i.e. the darcs executable must be in the default path on
the remote machine.

<P>
Push works by creating a patch bundle, and then running darcs apply in the
target repository using that patch bundle.  This means that the default
options for <SPAN  CLASS="textit">apply</SPAN> in the <SPAN  CLASS="textit">target</SPAN> repository (such as, for
example, <code>--test</code>) will affect the behavior of push.  This also means
that push is somewhat less efficient than pull.

<P>
When you receive an error message such as
<PRE>
bash: darcs: command not found
</PRE>
then this means that the darcs on the remote machine could
not be started.  Make sure that the darcs executable is called
<code>darcs</code> and is found in the default path.  The default path can
be different in interactive and in non-interactive shells.  Say
<PRE>
ssh login@remote.machine darcs
</PRE>
to try whether the remote darcs can be found, or
<PRE>
ssh login@remote.machine 'echo $PATH'
</PRE>
(note the single quotes) to check the default path.

<P>

<div class="cmd-opt-hdr">
--apply-as
</div>

<P>
If you give the <code>--apply-as</code> flag, darcs will use sudo to apply the
changes as a different user.  This can be useful if you want to set up a
system where several users can modify the same repository, but you don't
want to allow them full write access.  This isn't secure against skilled
malicious attackers, but at least can protect your repository from clumsy,
inept or lazy users.

<P>

<div class="cmd-opt-hdr">
--matches, --patches, --tags
</div>

<P>
The <code>--patches</code>, <code>--matches</code>, and <code>--tags</code> options can be
used to select which patches to push, as described in
subsection&nbsp;<A HREF="#selecting"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.  darcs will silently push along any other patches
upon which the selected patches depend.

<P>
When there are conflicts, the behavior of push is determined by the default
flags to <code>apply</code> in the <SPAN  CLASS="textit">target</SPAN> repository.  Most commonly, for
pushed-to repositories, you'd like to have <code>--dont-allow-conflicts</code> as
a default option to apply (by default, it is already the default...).  If
this is the case, when there are conflicts on push, darcs will fail with an
error message.  You can then resolve by pulling the conflicting patch,
recording a resolution and then pushing the resolution together with the
conflicting patch.

<P>
Darcs does not have an explicit way to tell you which patch conflicted, only the
file name. You may want to pull all the patches from the remote repo just
to be sure. If you don't want to do this in your working directory,
you can create another darcs working directory for this purpose.

<P>
If you want, you could set the target repo to use <code>--allow-conflicts</code>.
In this case conflicting patches will be applied, but the conflicts will
not be marked in the working directory.

<P>
If, on the other hand, you have <code>--mark-conflicts</code> specified as a
default flag for apply in the target repository, when there is a conflict,
it will be marked in the working directory of the target repository.  In
this case, you should resolve the conflict in the target repository itself.

<P>

<H2><A NAME="SECTION00754000000000000000">
darcs send</A>
</H2>

<P>
<code>Usage: darcs send [OPTION]... [REPOSITORY]</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--matches PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patches REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tags REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tags matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-a</code></TD>
<TD ALIGN="LEFT"><code>--all</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

answer yes to all patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from EMAIL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify email address</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-A</code></TD>
<TD ALIGN="LEFT"><code>--author EMAIL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify author id</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to EMAIL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify destination email</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--cc EMAIL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

mail results to additional EMAIL(s). Requires -reply</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-o</code></TD>
<TD ALIGN="LEFT"><code>--output FILE</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify output filename</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--sign</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

sign the patch with your gpg key</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--sign-as KEYID</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

sign the patch with a given keyid</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--sign-ssl IDFILE</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

sign the patch using openssl with a given private key</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-sign</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

do not sign the patch</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-u</code></TD>
<TD ALIGN="LEFT"><code>--unified</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

output patch in a darcs-specific format similar to diff -u</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dry-run</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't actually take the action</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-s</code></TD>
<TD ALIGN="LEFT"><code>--summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--context FILENAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

send to context stored in FILENAME</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--edit-description</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

edit the patch bundle description</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-edit-description</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't edit the patch bundle description</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--set-default</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

set default repository [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-set-default</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't set default repository</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--sendmail-command COMMAND</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify sendmail command</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Send is used to prepare a bundle of patches that can be applied to a target
repository.  Send accepts the URL of the repository as an argument.  When
called without an argument, send will use the most recent repository that
was either pushed to, pulled from or sent to.  By default, the patch bundle
is sent by email, although you may save it to a file.

<P>

<div class="cmd-opt-hdr">
--unified
</div>

<P>
If you want to create patches having context, you can use the
<code>--unified</code> option, which create output vaguely reminiscent of
<code>diff -u</code>. This format is still darcs-specific and should not
be expected to apply cleanly by <code>patch</code>.

<P>

<div class="cmd-opt-hdr">
--output, --to, --cc
</div>

<P>
The <code>--output</code> and <code>--to</code> flags determine what darcs does with
the patch bundle after creating it.  If you provide an <code>--output</code>
argument, the patch bundle is saved to that file.  If you give one or more
<code>--to</code> arguments, the bundle of patches is emailed to those addresses.

<P>
If you don't provide either a <code>--output</code> or a <code>--to</code> flag, darcs
will look at the contents of the <code>_darcs/prefs/email</code> file in the
target repository (if it exists), and send the patch by email to that
address.  In this case, you may use the <code>--cc</code> option to specify
additional recipients without overriding the default repository email
address.

<P>
If there is no email address associated with the repository, darcs will
prompt you for an email address.

<P>

<div class="cmd-opt-hdr">
--matches, --patches, --tags
</div>

<P>
The <code>--patches</code>, <code>--matches</code>, and <code>--tags</code> options can be
used to select which patches to send, as described in
subsection&nbsp;<A HREF="#selecting"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.  darcs will silently send along any other patches
upon which the selected patches depend.

<P>

<div class="cmd-opt-hdr">
--edit-description
</div>

<P>
If you want to include a description or explanation along with the bundle
of patches, you need to specify the <code>--edit-description</code> flag, which
will cause darcs to open up an editor with which you can compose an email
to go along with your patches.

<P>

<div class="cmd-opt-hdr">
--sendmail-command
</div>

<P>
If you want to use a command different from the default one for sending mails,
you need to specify a commandline with the <code>--sendmail-command</code> option. The
commandline can contain some format specifiers which are replaced by the actual
values. Accepted format specifiers are <code>%s</code> for subject, <code>%t</code> for to,
<code>%c</code> for cc, <code>%b</code> for the body of the mail, <code>%f</code> for from, <code>%a</code>
for the patch bundle and the same specifiers in uppercase for the urlencoded values.
Additionally you can add <code>%&lt;</code> to the end of the commandline if the command
expects the complete mail on standard input. E.g. the commandlines for evolution
and msmtp look like this:

<P>
<PRE>
evolution "mailto:%T?subject=%S&amp;attach=%A&amp;cc=%C&amp;body=%B"
msmtp %t %&lt;
</PRE>

<P>

<H2><A NAME="SECTION00755000000000000000">
darcs apply</A>
</H2>

<P>
<code>Usage: darcs apply [OPTION]... &lt;PATCHFILE&gt;</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--verify PUBRING</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

verify that the patch was signed by a key in PUBRING</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--verify-ssl KEYS</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

verify using openSSL with authorized keys from file 'KEYS'</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-verify</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't verify patch signature</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--reply FROM</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

reply to email-based patch using FROM address</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--cc EMAIL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

mail results to additional EMAIL(s). Requires -reply</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-a</code></TD>
<TD ALIGN="LEFT"><code>--all</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

answer yes to all patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--mark-conflicts</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

mark conflicts</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--allow-conflicts</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

allow conflicts, but don't mark them</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--external-merge COMMAND</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Use external tool to merge conflicts</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-resolve-conflicts</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

equivalent to -dont-allow-conflicts, for backwards compatibility</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-allow-conflicts</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

fail on patches that create conflicts [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--happy-forwarding</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

forward unsigned messages without extra header</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--leave-test-directory</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't remove the test directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--remove-test-directory</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

remove the test directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--sendmail-command COMMAND</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify sendmail command</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--set-scripts-executable</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

make scripts executable</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-set-scripts-executable</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't make scripts executable</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Apply is used to apply a bundle of patches to this repository.
Such a bundle may be created using send.

<P>
Darcs apply accepts a single argument, which is the name of the patch file
to be applied.  If you omit this argument, the patch is read from standard
input.<A NAME="tex2html19"
  HREF="#foot1106"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN></SUP></A>  This
allows you to use apply with a pipe from your email program, for example.

<P>

<div class="cmd-opt-hdr">
--verify
</div>

<P>
If you specify the <code>--verify PUBRING</code> option, darcs will check that
the patch was GPG-signed by a key which is in <code>PUBRING</code>, and will
refuse to apply the patch otherwise.

<P>

<div class="cmd-opt-hdr">
--cc, --reply
</div>

<P>
If you give the <code>--reply FROM</code> option to <code>darcs apply</code>, it will send the
results of the application to the sender of the patch.  This only works if
the patch is in the form of an email with its headers intact, so that darcs
can actually know the origin of the patch.  The reply email will indicate
whether or not the patch was successfully applied.  The <code>FROM</code> flag is
the email address that will be used as the ``from'' address when replying.
If the darcs apply is being done automatically, it is important that this
address not be the same as the address at which the patch was received, in
order to avoid automatic email loops.

<P>
If you want to also send the apply email to another address (for example,
to create something like a ``commits'' mailing list), you can use the
<code>--cc</code> option to specify additional recipients.  Note that the
<code>--cc</code> option <SPAN  CLASS="textit">requires</SPAN> the <code>--reply</code> option, which
provides the ``From'' address.

<P>
The <code>--reply</code> feature of apply is intended primarily for two uses.
When used by itself, it is handy for when you want to apply patches sent to
you by other developers so that they will know when their patch has been
applied.  For example, in my <code>.muttrc</code> (the config file for my mailer)
I have:
<PRE>
macro pager A "&lt;pipe-entry&gt;darcs apply --verbose \
        --reply droundy@abridgegame.org --repodir ~/darcs
</PRE>
which allows me to apply a patch to darcs directly from my mailer, with the
originator of that patch being sent a confirmation when the patch is
successfully applied.  NOTE: For some reason mutt seems to set the umask
such that patches created with the above macro are not world-readable.  I'm
not sure why this is, but use it with care.

<P>
When used in combination with the <code>--verify</code> option, the
<code>--reply</code> option allows for a nice pushable repository.  When these
two options are used together, any patches that don't pass the verify will
be forwarded to the <code>FROM</code> address of the <code>--reply</code> option.  This
allows you to set up a repository so that anyone who is authorized can push
to it and have it automatically applied, but if a stranger pushes to it,
the patch will be forwarded to you.  Please (for your own sake!) be certain
that the <code>--reply FROM</code> address is different from the one used to send
patches to a pushable repository, since otherwise an unsigned patch will be
forwarded to the repository in an infinite loop.

<P>
If you use `<code>darcs apply --verify PUBRING --reply</code>' to create a
pushable repo by applying patches automatically as they are received by
email, you will also want to use the <code>--dont-allow-conflicts</code> option.

<P>

<div class="cmd-opt-hdr">
--dont-allow-conflicts
</div>
The <code>--dont-allow-conflicts</code> flag causes apply to fail when applying a
patch would cause conflicts.  This flag is recommended on repositories
which will be pushed to or sent to.

<P>

<div class="cmd-opt-hdr">
--allow-conflicts
</div>

<P>
<code>--allow-conflicts</code> will allow conflicts, but will keep the local and
recorded versions in sync on the repo.  This means the conflict will exist
in both locations until it is resolved.

<P>

<div class="cmd-opt-hdr">
--mark-conflicts
</div>

<P>
<code>--mark-conflicts</code> will add conflict markers to illustrate the the
conflict.

<P>

<div class="cmd-opt-hdr">
--external-merge
</div>

<P>
You can use an external interactive merge tool to resolve conflicts with the
flag <code>--external-merge</code>.  For more details see
subsection&nbsp;<A HREF="#resolution"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.

<P>

<div class="cmd-opt-hdr">
--all, --gui, --interactive
</div>

<P>
If you provide the <code>--interactive</code> or <code>--gui</code> flag, darcs will
ask you for each change in the patch bundle whether or not you wish to
apply that change.  The opposite is the <code>--all</code> flag, which can be
used to override an <code>interactive</code> or <code>gui</code> which might be set in your
``defaults'' file.

<P>
NOTE: The GUI is not currently functional, but is expected to re-appear 
in a future release. 

<P>

<div class="cmd-opt-hdr">
--sendmail-command
</div>

<P>
If you want to use a command different from the default one for sending mail,
you need to specify a command line with the <code>--sendmail-command</code> option.
The command line can contain the format specifier <code>%t</code> for to
and you can add <code>%&lt;</code> to the end of the commandline if the command
expects the complete mail on standard input. E.g. the commandline for
msmtp looks like this:

<P>
<PRE>
msmtp %t %&lt;
</PRE>

<P>

<div class="cmd-opt-hdr">
--no-test, --test
</div>

<P>
If you specify the <code>--test</code> option, apply will run the test (if a test
exists) prior to applying the patch.  If the test fails, the patch is not
applied.  In this case, if the <code>--reply</code> option was used, the results
of the test are sent in the reply email.  You can also specify the
<code>--no-test</code> option, which will override the <code>--test</code> option, and
prevent the test from being run.  This is helpful when setting up a
pushable repository, to keep users from running code.

<P>

<H1><A NAME="SECTION00760000000000000000">
Seeing what you've done</A>
</H1>

<P>

<H2><A NAME="SECTION00761000000000000000"></A>
<A NAME="whatsnew"></A>
<BR>
darcs whatsnew
</H2>

<P>
<code>Usage: darcs whatsnew [OPTION]... [FILE or DIRECTORY]...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-s</code></TD>
<TD ALIGN="LEFT"><code>--summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-u</code></TD>
<TD ALIGN="LEFT"><code>--unified</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

output patch in a darcs-specific format similar to diff -u</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-l</code></TD>
<TD ALIGN="LEFT"><code>--look-for-adds</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

In addition to modifications, look for files that are not boring, and thus are potentially pending addition</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-look-for-adds</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Don't look for any files or directories that could be added, and don't add them automatically</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--boring</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't skip boring files</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Display unrecorded changes in the working copy.
whatsnew gives you a view of what changes you've made in your working
copy that haven't yet been recorded.  The changes are displayed in
darcs patch format. Note that -look-for-adds implies -summary usage.
 <code>darcs whatsnew</code> will return a non-zero value if
there are no changes, which can be useful if you just want to see in a
script if anything has been modified.  If you want to see some context
around your changes, you can use the <code>-u</code> option, to get output
similar to the unidiff format.

<P>
If you give one or more file or directory names as an argument to
<code>whatsnew</code>, darcs will output only changes to those files or to files in
those directories.

<P>

<H2><A NAME="SECTION00762000000000000000">
darcs changes</A>
</H2>

<P>
<code>Usage: darcs changes [OPTION]... [FILE or DIRECTORY]...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--last NUMBER</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select the last NUMBER patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--matches PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patches REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tags REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tags matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--context</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give output suitable for get -context</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--xml-output</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

generate XML formatted output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--human-readable</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give human-readable output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-s</code></TD>
<TD ALIGN="LEFT"><code>--summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--reverse</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

show changes in reverse order</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repo URL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository URL</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Changes gives a changelog-style summary of the repo history,
including options for altering how the patches are selected and displayed.

<P>
When given one or more files or directories as an argument, changes lists only
those patches which affect those files or the contents of those directories or,
of course, the directories themselves. This includes changes that happened to
files before they were moved or renamed.

<P>

<div class="cmd-opt-hdr">
--from-match, --from-patch, --from-tag
</div>

<P>
If changes is given a <code>--from-patch</code>, <code>--from-match</code>, or
<code>--from-tag</code> option, it outputs only those changes since that tag or
patch.

<P>
Without any options to limit the scope of the changes, history will be displayed
going back as far as possible.

<P>

<div class="cmd-opt-hdr">
--context, --human-readable, --xml-output
</div>

<P>
When given the <code>--context</code> flag, darcs changes outputs sufficient
information to allow the current state of the repository to be
recreated at a later date.  This information should generally be piped to a
file, and then can be used later in conjunction with
<code>darcs get --context</code> to recreate the current version.  Note that
while the <code>--context</code> flag may be used in conjunction with
<code>--xml-output</code> or <code>--human-readable</code>, in neither case will darcs
get be able to read the output.  On the other hand, sufficient information
<SPAN  CLASS="textit">will</SPAN> be output for a knowledgeable human to recreate the current
state of the repository.

<P>

<H2><A NAME="SECTION00763000000000000000"></A>
<A NAME="query-manifest"></A>
<BR>
darcs query manifest
</H2>

<P>
<code>Usage: darcs query manifest [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--files</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

include files in output [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-files</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

do not include files in output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--directories</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

include directories in output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-directories</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

do not include directories in output [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--pending</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

reflect pending patches in output [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-pending</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

only included recorded patches in output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-0</code></TD>
<TD ALIGN="LEFT"><code>--null</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

separate file names by NUL characters</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
The manifest command lists the version-controlled files in the
working copy.

<P>
By default (and if the <code>--pending</code> option is specified),
the effect of pending patches on the repository is taken into account.
In other words, if you add a file using <TT>darcs add</TT>, it
immediately appears in the output of <TT>query manifest</TT>, even if it
is not yet recorded.  If you specify the <code>--no-pending</code> option,
<TT>query manifest</TT> will only list recorded files (and directories).

<P>
The <code>--files</code> and <code>--directories</code> options control whether
files and directories are included in the output.  The
<code>--no-files</code>  and <code>--no-directories</code> options have the
reverse effect.  The default is to include files, but not directories.

<P>
If you specify the <code>--null</code> option, the file names are written to
standard output in unescaped form, and separated by ASCII NUL bytes.
This format is suitable for further automatic processing (for example,
using <code>xargs -0</code>).

<P>

<H1><A NAME="SECTION00770000000000000000">
More advanced commands</A>
</H1>

<P>

<H2><A NAME="SECTION00771000000000000000">
darcs tag</A>
</H2>

<P>
<code>Usage: darcs tag [OPTION]... [TAGNAME]</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-m</code></TD>
<TD ALIGN="LEFT"><code>--patch-name PATCHNAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

name of patch</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-A</code></TD>
<TD ALIGN="LEFT"><code>--author EMAIL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify author id</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--checkpoint</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create a checkpoint file</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--pipe</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

expect to receive input from a pipe</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Tag is used to name a version of this repository (i.e. the whole tree).
 Tag differs from record in that it doesn't record any
new changes, and it always depends on all patches residing in the
repository when it is tagged.  This means that one can later reproduce this
version of the repository by calling, for example:
<PRE>
% darcs get --tag "darcs 3.14" REPOLOCATION
</PRE>

<P>
Each tagged version has a version name.
The version is also flagged with the person who tagged it (taken by default
from the `DARCS_EMAIL' or `EMAIL' environment variable).  The date is also
included in the version information.

<P>
A tagged version automatically depends on all patches in the repo.  This
allows you to later reproduce precisely that version.  The tag does this by
depending on all patches in the repo, except for those which are depended
upon by other tags already in the repo.  In the common case of a sequential
series of tags, this means that the tag depends on all patches since the
last tag, plus that tag itself.

<P>

<div class="cmd-opt-hdr">
--checkpoint
</div>
The <code>--checkpoint</code> option allows the tag be used later with the
<code>--partial</code> flag to <code>get</code> or <code>check</code>.

<P>
A partial repository only contains patches from after the checkpoint.  A
partial repository works just like a normal repository, but any command that
needs to look at the contents of a missing patch will complain and abort.

<P>

<div class="cmd-opt-hdr">
--pipe
</div>

<P>
If you run tag with the <code>--pipe</code> option, you will be prompted for the
tag name and date.  This interface is intended for scripting darcs, in
particular for writing repository conversion scripts.  The prompts are
intended mostly as useful guide (since scripts won't need them), to help
you understand the format in which to provide the input. Here's an example
of what the <code>--pipe</code> prompts looks like:

<P>
<PRE>
 What is the date? Mon Nov 15 13:38:01 EST 2004
 Who is the author? David Roundy
 What is the version name? 3.0
 Finished tagging patch 'TAG 3.0'
</PRE>

<P>
Using <code>tag</code> creates an entry in the repo history just like <code>record</code>.
It will show up with <code>darcs changes</code> appearing in the format:

<P>
<PRE>
 tagged My Tag Name
</PRE>

<P>
Because the word `tagged' is always prepended to the tag name, you can search
for tag names by simply passing the output of <code>darcs changes</code> through <code>grep</code>:

<P>
<PRE>
 darcs changes | grep tagged
</PRE>

<P>
The above example would display all the tag names in use in the repo.

<P>

<H2><A NAME="SECTION00772000000000000000">
darcs setpref</A>
</H2>

<P>
<code>Usage: darcs setpref [OPTION]... &lt;PREF&gt; &lt;VALUE&gt;</code>

<P>
Options:

<P>


<P>
Usage example:
<PRE>
% darcs setpref test "echo I am not really testing anything."
</PRE>

<P>
Setpref allows you to set a preference value in a way that will
propagate to other repositories.

<P>
Valid preferences are: test predist boringfile binariesfile.
 If you just want to set the pref value in your
repository only, you can just edit ``<code>_darcs/prefs/prefs</code>''.  Changes
you make in that file will be preserved.

<P>
The ``<code>_darcs/prefs/prefs</code>'' holds the only preferences information
that can propagate between repositories by pushes and pulls, and the only
way this happens is when the setprefs command is used.  Note that although
prefs settings are included in patches, they are <SPAN  CLASS="textit">not</SPAN> fully version
controlled.  In particular, depending on the order in which a series of
merges is performed, you may end up with a different final prefs
configuration.  In practice I don't expect this to be a problem, as the
prefs usually won't be changed very often.

<P>
The following values are valid preferences options which can be configured
using setpref:

<UL>
<LI>``test'' -- the command to run as a test script.
</LI>
<LI>``predist'' -- a command to run prior to tarring up a distribution
  tarball.  Typically this would consist of autoconf and/or automake.
</LI>
<LI>``boringfile'' -- the name of a file to read instead of the
  ``boring'' prefs file.
</LI>
<LI>``binariesfile'' -- the name of a file to read instead of the
  ``binaries'' prefs file.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00773000000000000000">
darcs check</A>
</H2>

<P>
<code>Usage: darcs check [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--complete</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

check the entire repository</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--partial</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

check patches since latest checkpoint</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--leave-test-directory</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't remove the test directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--remove-test-directory</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

remove the test directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Check the repository for consistency.
Check verifies that the patches stored in the repository, when successively
applied to an empty tree, properly recreate the stored pristine tree.

<P>

<div class="cmd-opt-hdr">
--complete, --partial
</div>

<P>
If you have a checkpoint of the repository (as is the case if you got the
repo originally using <code>darcs get --partial</code>), by default darcs check
will only verify the contents since the most recent checkpoint.  You can
change this behavior using the <code>--complete</code> flag.

<P>
If you like, you can configure your repository to be able to run a test
suite of some sort.  You can do this by using ``setpref'' to set the
``test'' value to be a command to run, e.g.
<PRE>
% darcs setpref test "sh configure &amp;&amp; make &amp;&amp; make test"
</PRE>
Or, if you want to define a test specific to one copy of the repository,
you could do this by editing the file <code>_darcs/prefs/prefs</code>.

<P>

<div class="cmd-opt-hdr">
--leave-test-directory, --remove-test-directory
</div>

<P>
Normally darcs deletes the directory in which the test was run afterwards.
Sometimes (especially when the test fails) you'd prefer to be able to be
able to examine the test directory after the test is run.  You can do this
by specifying the <code>--leave-test-directory</code> flag.  Alas, there is no
way to make darcs leave the test directory only if the test fails.  The
opposite of <code>--leave-test-directory</code> is
<code>--remove-test-directory</code>, which could come in handy if you choose to
make <code>--leave-test-directory</code> the default (see
section&nbsp;<A HREF="#defaults"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>).

<P>

<div class="cmd-opt-hdr">
--no-test
</div>

<P>
If you just want to check the consistency of your repository without
running the test, you can call darcs check with the <code>--no-test</code>
option.

<P>

<H2><A NAME="SECTION00774000000000000000">
darcs optimize</A>
</H2>

<P>
<code>Usage: darcs optimize [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--checkpoint</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create a checkpoint file</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--uncompress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

uncompress patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tag TAGNAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

name of version to checkpoint</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--modernize-patches</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

rewrite all patches in current darcs format</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--reorder-patches</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

reorder the patches in the repository</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--sibling URL</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify a sibling directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--relink</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

relink random internal data to a sibling</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--relink-pristine</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

relink pristine tree (not recommended)</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Optimize can help to improve the performance of your repository in a number of cases.

<P>
Optimize always writes out a fresh copy of the inventory that minimizes
the amount of inventory that need be downloaded when people pull from the
repo.

<P>
Specifically, it breaks up the inventory on the most recent tag.  This speeds
up most commands when run remotely, both because a smaller file needs to be
transfered (only the most recent inventory).  It also gives a
guarantee that all the patches prior to a given tag are included in that tag,
so less commutation and history traversal is needed.  This latter issue can
become very important in large repositories.

<P>

<div class="cmd-opt-hdr">
--checkpoint, --tag
</div>

<P>
If you use the <code>--checkpoint</code> option, optimize creates a checkpoint patch
for a tag.  You can specify the tag with the <code>--tag</code> option, or
just let darcs choose the most recent tag.  Note that optimize
<code>--checkpoint</code> will fail when used on a ``partial'' repository.  Also,
the tag that is to be checkpointed must not be preceded by any patches
that are not included in that tag.  If that is the case, no checkpointing
is done.

<P>
The created checkpoint is used by the <code>--partial</code> flag to 
<code>get</code> and <code>check</code>. This allows for users to retrieve
a working repository with limited history with a savings of disk
space and bandwidth. 

<P>

<div class="cmd-opt-hdr">
--compress, --dont-compress, --uncompress
</div>

<P>
Some compression options are available, and are independent of the
<code>--checkpoint</code> option.

<P>
By default the patches in the repository are compressed. These use less
disk space, which translates into less bandwidth if the repository is accessed
remotely.  Note that patches will always have the ``.gz'' extension whether
they are compressed or not.

<P>
You may want to uncompress the patches when you've got enough disk space but
are running out of physical memory.

<P>
If you give the <code>--compress</code> option, optimize will compress all the
patches in the repository.  Similarly, if you give the <code>--uncompress</code>,
optimize will decompress all the patches in the repository.
<code>--dont-compress</code>  means ``don't compress, but don't uncompress
either''. It would be useful if one of the compression options was provided
as a default and you wanted to override it.

<P>

<div class="cmd-opt-hdr">
--modernize-patches
</div>

<P>
If you provide the <code>--modernize-patches</code> argument, darcs will convert
obsolete patches into the current darcs format.  This affects both the
patch contents and the patch formatting.

<P>
Older versions of darcs formatted the long comments slightly differently,
which can cause trouble with third-party tools that wish to parse the darcs
patches, although darcs itself still reads the older patches fine.
<code>--modernize-patches</code>  standardizes the formatting of all patches.

<P>
In addition, <SPAN  CLASS="textit">very</SPAN> old versions of darcs created the ``merger 0.9''
patch type when there were conflicts.  This patch type inherently had bugs
which could lead to corruption, which is why it was phased out.
<code>--modernize-patches</code> will convert old ``merger 0.9'' patches into
an equivalent change (which will, however, commute differently).

<P>

<div class="cmd-opt-hdr">
--relink
</div>

<P>
The <code>--relink</code> and <code>--relink-pristine</code> options cause Darcs
to relink files from a sibling.  See Section <A HREF="#disk-usage"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.

<P>

<div class="cmd-opt-hdr">
--reorder-patches
</div>

<P>
The <code>--reorder-patches</code> option causes Darcs to create an optimal
ordering of its internal patch inventory. This may help to produce shorter
`context' lists when sending patches, and may improve performance for some
other operations as well.  You should not run <code>--reorder-patches</code> on a
repository from which someone may be simultaneously pulling or getting, as
this could lead to repository corruption.

<P>

<H1><A NAME="SECTION00780000000000000000">
Undoing, redoing and running in circles</A>
</H1>

<P>

<H2><A NAME="SECTION00781000000000000000">
darcs amend-record</A>
</H2>

<P>
<code>Usage: darcs amend-record [OPTION]... [FILE or DIRECTORY]...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--test</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

run the test script</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--leave-test-directory</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't remove the test directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--remove-test-directory</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

remove the test directory</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-a</code></TD>
<TD ALIGN="LEFT"><code>--all</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

answer yes to all patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-l</code></TD>
<TD ALIGN="LEFT"><code>--look-for-adds</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

In addition to modifications, look for files that are not boring, and thus are potentially pending addition</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-look-for-adds</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

Don't look for any files or directories that could be added, and don't add them automatically</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Amend-record is used to replace a patch with a newer version with additional
changes.

<P>
WARNINGS: You should ONLY use amend-record on patches which only exist in a
single repository! Also, running amend-record while another user is pulling
from the same repo may cause repository corruption.

<P>
If you provide one or more files or directories as additional arguments to
amend-record, you will only be prompted to changes in those files or
directories.

<P>
The old version of the patch is lost and the new patch will include both the
old and the new changes.  This is mostly the same as unrecording the old patch,
fixing the changes and recording a new patch with the same name and
description.

<P>
<code>amend-record</code> will modify the date of the recorded patch.  

<P>
If you configure darcs to run a test suite, darcs will run this test on the
amended repo to make sure it is valid.  Darcs first creates a pristine
copy of the source tree (in a temporary directory), then it runs the test,
using its return value to decide if the amended change is valid.

<P>

<H2><A NAME="SECTION00782000000000000000">
darcs rollback</A>
</H2>

<P>
<code>Usage: darcs rollback [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Rollback is used to undo the effects of a single patch without actually
deleting that patch.  Instead, it applies the inverse patch as a new patch.
Unlike unpull and unrecord (which accomplish a similar goal) rollback is
perfectly safe, since it leaves in the repository a record of the patch it
is removing.
 If you decide you didn't want to roll back a patch
after all, you probably should use unrecord to undo the rollback, since
like rollback, unrecord doesn't affect the working directory.

<P>

<H2><A NAME="SECTION00783000000000000000">
darcs unrecord</A>
</H2>

<P>
<code>Usage: darcs unrecord [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--last NUMBER</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select the last NUMBER patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--matches PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patches REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tags REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tags matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Unrecord does the opposite of record in that it makes the changes from
patches active changes again which you may record or revert later.  The
working copy itself will not change.

<P>
Unrecord can be thought of as undo-record.
If a record is followed by an unrecord, everything looks like before
the record; all the previously unrecorded changes are back, and can be
recorded again in a new patch. The unrecorded patch however is actually
removed from your repository, so there is no way to record it again to get
it back.<A NAME="tex2html20"
  HREF="#foot1492"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN></SUP></A>.

<P>
If you want to remove
the changes from the working copy too (where they otherwise will show
up as unrecorded changes again), you'll also need to <code>darcs revert</code>.
To do unrecord and revert in one go, you can use <code>darcs unpull</code>.

<P>
If you don't revert after unrecording, then the changes made by the
unrecorded patches are left in your working tree.  If these patches are
actually from another repository, interaction (either pushes or pulls) with
that repository may be massively slowed down, as darcs tries to cope with
the fact that you appear to have made a large number of changes that
conflict with those present in the other repository.  So if you really want
to undo the result of a <SPAN  CLASS="textit">pull</SPAN> operation, use unpull! Unrecord is
primarily intended for when you record a patch, realize it needs just one
more change, but would rather not have a separate patch for just that one
change.

<P>

<P>

<SPAN  CLASS="textbf">WARNING:</SPAN> Unrecord should not be run when there is a possibility
that another user may be pulling from the same repo.  Attempting to do so
may cause repository corruption.

<P>

<div class="cmd-opt-hdr">
--from-match, --from-patch, --from-tag, --last
</div>

<P>
Usually you only want to unrecord the latest changes,
and almost never would you want to unrecord changes before a tag--you
would have to have unrecorded the tag as well to do that.
Therefore, and for efficiency, darcs only prompts you for the latest patches,
after some optimal tag.

<P>
If you do want to unrecord more patches in one go,
there are the <code>--from</code> and <code>--last</code> options
to set the earliest patch selectable to unrecord.

<P>

<div class="cmd-opt-hdr">
--matches, --patches, --tags
</div>

<P>
With these options you can specify
what patch or patches to be prompted for by unrecord.
This is especially useful when you want to unrecord patches with dependencies,
since all the dependent patches (but no others) will be included in the choices.

<P>
These options can be slow if the list of patches to match is long,
which can happen if <code>--from</code> or <code>--last</code> is used.
The latter options can of course be used to <SPAN  CLASS="textit">shorten</SPAN> the list too,
if it is long by default.

<P>

<H2><A NAME="SECTION00784000000000000000">
darcs unpull</A>
</H2>

<P>
<code>Usage: darcs unpull [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--last NUMBER</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select the last NUMBER patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--matches PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patches REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tags REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tags matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Unpull completely removes recorded patches from your local repository.
The changes will be undone in your working copy and the patches will not be
shown in your changes list anymore.
Beware that if the patches are not still present in another repo you will lose
precious code by unpulling!

<P>
Unlike unrecord, unpull does not just delete the patch from the repository,
it actually applies an inverse patch to the repository.  This makes
unpull a particularly dangerous command, as it not only deletes the patch
from the repo, but also removes the changes from the working directory.  It
is equivalent to an unrecord followed by a revert, except that revert can
be unreverted.

<P>

<SPAN  CLASS="textbf">WARNING:</SPAN> Unpull should not be run when there is a possibility
that another user may be pulling from the same repo.  Attempting to do so
may cause repository corruption.

<P>
Contrary to what its name suggests, there is nothing in unpull that
requires that the ``unpulled'' patch originate from a different repository.
The name was chosen simply to suggest a situation in which it is ``safe''
to use unpull.  If the patch was originally from another repo, then
unpulling is safe, because you can always pull the patch again if you
decide you want it after all.  If you unpull a locally recorded patch, all
record of that change is lost, which is what makes this a ``dangerous''
command, and thus deserving of an obscure name which is more suggestive of
when it is safe to use than precisely what it does.

<P>

<div class="cmd-opt-hdr">
--from-match, --from-patch, --from-tag, --last
</div>

<P>
For efficiency, darcs only prompts you for the latest patches,
after some optimal tag.
If you do want to unpull more patches in one go,
there are the <code>--from</code> and <code>--last</code> options
to set the earliest patch selectable to unpull.

<P>

<div class="cmd-opt-hdr">
--matches, --patches, --tags
</div>

<P>
With these options you can specify
what patch or patches to be prompted for by unpull.
This is especially useful when you want to unpull patches with dependencies,
since all the dependent patches (but no others) will be included in the choices.

<P>
In the case of tags, what you are unpulling is the tag itself, not any other patches.

<P>
These options can be slow if the list of patches to match with is long,
which can happen if <code>--from</code> or <code>--last</code> is used.
The latter options can of course be used to <SPAN  CLASS="textit">shorten</SPAN> the list too,
if it is long by default.

<P>

<H2><A NAME="SECTION00785000000000000000">
darcs obliterate</A>
</H2>

<P>
<code>Usage: darcs obliterate [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--last NUMBER</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select the last NUMBER patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--matches PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patches REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patches matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tags REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tags matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--dont-compress</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't create compressed patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Obliterate completely removes recorded patches from your local repository.
The changes will be undone in your working copy and the patches will not be
shown in your changes list anymore.
Beware that you can lose precious code by obliterating!

<P>
Obliterate deletes a patch from the repository <SPAN  CLASS="textit">and</SPAN> removes those
changes from the working directory.  It is therefore a <SPAN  CLASS="textit">very
dangerous</SPAN> command.  When there are no local changes, obliterate is
equivalent to an unrecord followed by a revert, except that revert can be
unreverted.  In the case of tags, obliterate removes the tag itself, not
any other patches.

<P>
Note that obliterate is currently an alias for unpull.

<P>

<SPAN  CLASS="textbf">WARNING:</SPAN> Obliterate should not be run when there is a possibility
that another user may be pulling from the same repo.  Attempting to do so
may cause repository corruption.

<P>

<div class="cmd-opt-hdr">
--from-match, --from-patch, --from-tag, --last
</div>

<P>
For efficiency, darcs only prompts you for the latest patches, after some
optimal tag.  If you do want to unpull more patches in one go, there are
the <code>--from</code> and <code>--last</code> options to set the earliest patch
selectable to unpull.

<P>

<div class="cmd-opt-hdr">
--matches, --patches, --tags
</div>

<P>
With these options you can specify what patch or patches to be prompted for
by unpull.  This is especially useful when you want to unpull patches with
dependencies, since all the dependent patches (but no others) will be
included in the choices.

<P>

<H2><A NAME="SECTION00786000000000000000">
darcs revert</A>
</H2>

<P>
<code>Usage: darcs revert [OPTION]... [FILE or DIRECTORY]...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-a</code></TD>
<TD ALIGN="LEFT"><code>--all</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

answer yes to all patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Revert is used to undo changes made to the working copy which have
not yet been recorded.  You will be prompted for which changes you
wish to undo. The last revert can be undone safely using the unrevert
command if the working copy was not modified in the meantime.
 The actions of a revert may be reversed using the
unrevert command (see subsection&nbsp;<A HREF="#unrevert"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>).  However, if you've made
changes since the revert your mileage may vary, so please be careful.

<P>
You can give revert optional arguments indicating files or directories.  If
you do so it will only prompt you to revert changes in those files or in
files in those directories.

<P>

<H2><A NAME="SECTION00787000000000000000"></A><A NAME="unrevert"></A>
<BR>
darcs unrevert
</H2>

<P>
<code>Usage: darcs unrevert [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-a</code></TD>
<TD ALIGN="LEFT"><code>--all</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

answer yes to all patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--interactive</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

prompt user interactively</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Unrevert is used to undo the results of a revert command. It is only
guaranteed to work properly if you haven't made any changes since the
revert was performed.

<P>
The command makes a best effort to merge the unreversion with any changes
you have since made.  In fact, unrevert should even work if you've recorded
changes since reverting.

<P>

<H1><A NAME="SECTION00790000000000000000">
Advanced examination of the repository</A>
</H1>

<P>

<H2><A NAME="SECTION00791000000000000000">
darcs diff</A>
</H2>

<P>
<code>Usage: darcs diff [OPTION]... [FILE or DIRECTORY]...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--to-tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes up to a tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--from-tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select changes starting with a tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select a single patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select a single patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--last NUMBER</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select the last NUMBER patches</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--diff-opts OPTIONS</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

options to pass to diff</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-u</code></TD>
<TD ALIGN="LEFT"><code>--unified</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

pass -u option to diff</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Diff can be used to create a diff between two versions which are in your
repository.  Specifying just -from-patch will get you a diff against
your working copy.  If you give diff no version arguments, it gives
you the same information as whatsnew except that the patch is
formatted as the output of a diff command

<P>

<div class="cmd-opt-hdr">
--diff-opts
</div>

<P>
Diff calls an external ``diff'' command to do the actual work, and passes
any unrecognized flags to this diff command.  Thus you can call
<PRE>
% darcs diff -t 0.9.8 -t 0.9.10 -- -u
</PRE>
to get a diff in the unified format.  Actually, thanks to the wonders of
getopt you need the ``<code>--</code>'' shown above before any arguments to diff.
You can also specify additional arguments to diff using the
<code>--diff-opts</code> flag.  The above command would look like this:
<PRE>
% darcs diff --diff-opts -u -t 0.9.8 -t 0.9.10
</PRE>
This may not seem like an improvement, but it really pays off when you want
to always give diff the same options.  You can do this by adding
<PRE>
% diff diff-opts -udp
</PRE>
to your <code>_darcs/prefs/defaults</code> file.

<P>
If you want to view only the differences to one or more files, you can do
so with a command such as
<PRE>
% darcs diff foo.c bar.c baz/
</PRE>

<P>
FIXME: I should allow the user to specify the external diff command.
Currently it is hardwired to ``diff''.

<P>

<H2><A NAME="SECTION00792000000000000000"></A>
<A NAME="annotate"></A>
<BR>
darcs annotate
</H2>

<P>
<code>Usage: darcs annotate [OPTION]... [FILE or DIRECTORY]...</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-s</code></TD>
<TD ALIGN="LEFT"><code>--summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-summary</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't summarize changes</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-u</code></TD>
<TD ALIGN="LEFT"><code>--unified</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

output patch in a darcs-specific format similar to diff -u</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--human-readable</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give human-readable output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--xml-output</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

generate XML formatted output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--match PATTERN</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patch matching PATTERN</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-p</code></TD>
<TD ALIGN="LEFT"><code>--patch REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select patch matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-t</code></TD>
<TD ALIGN="LEFT"><code>--tag REGEXP</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

select tag matching REGEXP</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--creator-hash HASH</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify hash of creator patch (see docs)</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Display which patch last modified something.
Annotate displays which patches created or last modified a directory
file or line. It can also display the contents of a particular patch
in darcs format.

<P>

<div class="cmd-opt-hdr">
--human-readable, --summary, --unified, --xml--output
</div>

<P>
When called with just a patch name, annotate outputs the patch in darcs format,
which is the same as <code>--human-readable</code>.

<P>
<code>--xml-output</code> is the alternative to <code>--human-readable</code>.

<P>
<code>--summary</code> can be used with either the <code>--xml-output</code> or the  
<code>--human-readable</code> options to alter the results. It is documented
fully in the `common options' portion of the manual. 

<P>
Giving the <code>--unified</code> flag implies <code>--human-readable</code>, and causes
the output to remain in a darcs-specific format that is similar to that produced
by <code>diff --unified</code>.

<P>
If a directory name is given, annotate will output details of the last
modifying patch for each file in the directory and the directory itself. The
details look like this:

<P>
<PRE>
 # Created by [bounce handling patch
 # mark**20040526202216]  as ./test/m7/bounce_handling.pl
    bounce_handling.pl
</PRE>

<P>
If a patch name and a directory are given, these details are output for the time after
that patch was applied.  If a directory and a tag name are given, the
details of the patches involved in the specified tagged version will be output.

<P>
If a file name is given, the last modifying patch details of that file will be output, along
with markup indicating patch details when each line was last (and perhaps next) modified.

<P>

<div class="cmd-opt-hdr">
--creator-hash HASH
</div>

<P>
The <code>--creator-hash</code> option should only be used in combination with a
file or directory to be annotated.  In this case, the name of that file or
directory is interpreted to be its name <SPAN  CLASS="textit">at the time it was created</SPAN>,
and the hash given along with <code>--creator-hash</code> indicates the patch
that created the file or directory.  This allows you to (relatively) easily
examine a file even if it has been renamed multiple times.

<P>

<H2><A NAME="SECTION00793000000000000000"></A>
<A NAME="query-manifest"></A>
<BR>
darcs query manifest
</H2>

<P>
<code>Usage: darcs query manifest [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--files</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

include files in output [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-files</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

do not include files in output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--directories</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

include directories in output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-directories</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

do not include directories in output [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--pending</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

reflect pending patches in output [DEFAULT]</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--no-pending</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

only included recorded patches in output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-0</code></TD>
<TD ALIGN="LEFT"><code>--null</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

separate file names by NUL characters</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
The manifest command lists the version-controlled files in the
working copy.

<P>
By default (and if the <code>--pending</code> option is specified),
the effect of pending patches on the repository is taken into account.
In other words, if you add a file using <TT>darcs add</TT>, it
immediately appears in the output of <TT>query manifest</TT>, even if it
is not yet recorded.  If you specify the <code>--no-pending</code> option,
<TT>query manifest</TT> will only list recorded files (and directories).

<P>
The <code>--files</code> and <code>--directories</code> options control whether
files and directories are included in the output.  The
<code>--no-files</code>  and <code>--no-directories</code> options have the
reverse effect.  The default is to include files, but not directories.

<P>
If you specify the <code>--null</code> option, the file names are written to
standard output in unescaped form, and separated by ASCII NUL bytes.
This format is suitable for further automatic processing (for example,
using <code>xargs -0</code>).

<P>

<H1><A NAME="SECTION007100000000000000000">
Rarely needed and obscure commands</A>
</H1>

<P>

<H2><A NAME="SECTION007101000000000000000">
darcs resolve</A>
</H2>

<P>
<code>Usage: darcs resolve [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--ignore-times</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't trust the file modification times</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--repodir DIRECTORY</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

specify the repository directory in which to run</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Resolve is used to mark and resolve any conflicts that may exist in a
repository.  Note that this trashes any unrecorded changes in the working
copy.

<P>

<H2><A NAME="SECTION007102000000000000000">
darcs dist</A>
</H2>

<P>
<code>Usage: darcs dist [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-d</code></TD>
<TD ALIGN="LEFT"><code>--dist-name DISTNAME</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

name of version</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Create a distribution tarball.

<P>
Dist is a handy tool for implementing a "make dist" target in your
makefile.  It creates a tarball of the recorded edition of your tree.
 Basically, you will typically use it in a makefile
rule such as
<PRE>
dist:
    darcs dist --dist-name darcs-`./darcs --version`
</PRE>
<code>darcs dist</code> then simply creates a clean copy of the source tree,
which it then tars and gzips.  If you use programs such as autoconf or
automake, you really should run them on the clean tree before tarring it up
and distributing it.  You can do this using the pref value ``predist'',
which is a shell command that is run prior to tarring up the distribution:
<PRE>
% darcs setpref predist "autoconf &amp;&amp; automake"
</PRE>

<P>

<H2><A NAME="SECTION007103000000000000000">
darcs trackdown</A>
</H2>

<P>
<code>Usage: darcs trackdown [OPTION]... [[INITIALIZATION] COMMAND]</code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

don't give verbose output</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Trackdown tries to find the most recent version in the repository which
passes a test.  Given no arguments, it uses the default repository test.
Given one argument, it treats it as a test command.  Given two arguments,
the first is an initialization command with is run only once, and the
second is the test command.

<P>
Trackdown is helpful for locating when something was broken.  It creates
a temporary directory with the latest repo content in it and cd to it.
First, and only once, it runs the initialization command if any,
for example
<PRE>
'autoconf; ./configure &gt;/dev/null'
</PRE>
Then it runs the test command, for example
<PRE>
'make &amp;&amp; cd tests &amp;&amp; sh /tmp/test.sh'
</PRE>
While the test command exits with an error return code, darcs
``unapplies'' one patch from the version controlled files to retrieve
an earlier version, and repeats the test command.  If the test command
finally succeeds, the name of the hunted down patch is found in the
output before the last test run.

<P>
FIXME: It is
still rather primitive.  Currently it just goes back over the history in
reverse order trying each version.  I'd like for it to explore different
patch combinations, to try to find the minimum number of patches that you
would need to unpull in order to make the test succeed.

<P>
FIXME: I also would like to add an interface by which you can tell it which
patches it should consider not including.  Without such a feature, the
following command:
<PRE>
% darcs trackdown 'make &amp;&amp; false'
</PRE>
would result in compiling every version in the repository-which is a
rather tedious prospect.

<P>

<H3><A NAME="SECTION007103100000000000000">
Example usage</A>
</H3>
If you want to find the last version of darcs that had a FIXME note in the
file Record.lhs, you could run
<PRE>
% darcs trackdown 'grep FIXME Record.lhs'
</PRE>

<P>
To find the latest version that compiles, you can run
<PRE>
% darcs trackdown 'autoconf' './configure &amp;&amp; make'
</PRE>

<P>
Trackdown can also be used to see how other features of the code changed
with time.  For example
<PRE>
% darcs trackdown 'autoconf; ./configure' \
   "make darcs &amp;&gt; /dev/null &amp;&amp; cd ~/darcs &amp;&amp; time darcs check &amp;&amp; false"
</PRE>
would let you see how long `darcs check' takes to run on each previous
version of darcs that will actually compile.  The ``<code>&amp;&amp; false</code>''
ensures that trackdown keeps going.

<P>

<H2><A NAME="SECTION007104000000000000000">
darcs repair</A>
</H2>

<P>
<code>Usage: darcs repair [OPTION]... </code>

<P>
Options:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><code>-v</code></TD>
<TD ALIGN="LEFT"><code>--verbose</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

give verbose output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>-q</code></TD>
<TD ALIGN="LEFT"><code>--quiet</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

suppress informational output</TD></TR>
</TABLE></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><code>--standard-verbosity</code></TD>
<TD ALIGN="LEFT"><TABLE  WIDTH="317">
<TR><TD>

neither verbose nor quiet output</TD></TR>
</TABLE></TD>
</TR>
</TABLE>

<P>
Repair attempts to fix corruption that may have entered your
repository.

<P>
Repair currently will only repair damage to the pristine tree.
Fortunately this is just the sort of corruption that is most
likely to happen.

<P>

<P>

<H1><A NAME="SECTION00800000000000000000"></A>
<A NAME="Patch"></A>
<BR>
Theory of patches
</H1>

<P>
  
<P>

<H1><A NAME="SECTION00810000000000000000">
Background</A>
</H1>

<P>
I think a little background on the author is in order.  I am a physicist,
and think like a physicist.  The proofs and theorems given here are what I
would call ``physicist'' proofs and theorems, which is to say that while
the proofs may not be rigorous, they are practical, and the theorems are
intended to give physical insight.  It would be great to have a
mathematician work on this, but I am not a mathematician, and don't care
for math.

<P>
From the beginning of this theory, which originated as the result of a
series of email discussions with Tom Lord, I have looked at patches as
being analogous to the operators of quantum mechanics.  I include in this
appendix footnotes explaining the theory of patches in terms of the theory
of quantum mechanics.  I know that for most people this won't help at all,
but many of my friends (and as I write this all three of darcs' users) are
physicists, and this will be helpful to them.  To non-physicists, perhaps it
will provide some insight into how at least this physicist thinks.

<P>

<H1><A NAME="SECTION00820000000000000000">
Introduction</A>
</H1>

<P>
A patch describes a change to the tree.  It could be either a primitive
patch (such as a file add/remove, a directory rename, or a hunk replacement
within a file), or a composite patch describing many such changes.  Every
patch type must satisfy the conditions described in this appendix.  The
theory of patches is independent of the data which the patches manipulate,
which is what makes it both powerful and useful, as it provides a framework
upon which one can build a revision control system in a sane manner.

<P>
Although in a sense, the defining property of any patch is that it can be
applied to a certain tree, and thus make a certain change, this change does
not wholly define the patch.  A patch is defined by a
<SPAN  CLASS="textit">representation</SPAN>, together with a set of rules for how it behaves
(which it has in common with its patch type).  The <SPAN  CLASS="textit">representation</SPAN> of
a patch defines what change that particular patch makes, and must be
defined in the context of a specific tree.  The theory of patches is a
theory of the many ways one can change the representation of a patch to
place it in the context of a different tree.  The patch itself is not
changed, since it describes a single change, which must be the same
regardless of its representation<A NAME="tex2html21"
  HREF="#foot2008"><SUP>A.<SPAN CLASS="arabic">1</SPAN></SUP></A>.

<P>
So how does one define a tree, or the context of a patch? The simplest way
to define a tree is as the result of a series of patches applied to the
empty tree<A NAME="tex2html22"
  HREF="#foot1842"><SUP>A.<SPAN CLASS="arabic">2</SPAN></SUP></A>.  Thus, the
context of a patch consists of the set of patches that precede it.

<P>

<H1><A NAME="SECTION00830000000000000000">
Applying patches</A>
</H1>

<P>

<H2><A NAME="SECTION00831000000000000000">
Hunk patches</A>
</H2>

<P>
Hunks are an example of a complex filepatch.  A hunk is a set of lines of a
text file to be replaced by a different set of lines.  Either of these sets
may be empty, which would mean a deletion or insertion of lines.

<P>

<H2><A NAME="SECTION00832000000000000000"></A><A NAME="token_replace"></A>
<BR>
Token replace patches
</H2>

<P>
Although most filepatches will be hunks, darcs is clever enough to support
other types of changes as well.  A ``token replace'' patch replaces all
instances of a given token with some other version.  A token, here, is
defined by a regular expression, which must be of the simple [a-z...] type,
indicating which characters are allowed in a token, with all other
characters acting as delimiters.  For example, a C identifier would be a
token with the flag <code>[A-Za-z_0-9]</code>.

<P>
What makes the token replace patch special is the fact that a token replace
can be merged with almost any ordinary hunk, giving exactly what you would
want.  For example, you might want to change the patch type <TT>TokReplace</TT> to <TT>TokenReplace</TT> (if you decided that saving two
characters of space was stupid).  If you did this using hunks, it would
modify every line where <TT>TokReplace</TT> occurred, and quite likely provoke
a conflict with another patch modifying those lines.  On the other hand, if
you did this using a token replace patch, the only change that it could
conflict with would be if someone else had used the token ``<TT>TokenReplace</TT>'' in their patch rather than TokReplace--and that actually
would be a real conflict!

<P>

<H1><A NAME="SECTION00840000000000000000">
Patch relationships</A>
</H1>

<P>
The simplest relationship between two patches is that of ``sequential''
patches, which means that the context of the second patch (the one on the
left) consists of the first patch (on the right) plus the context of the
first patch.  The composition of two patches (which is also a patch) refers
to the patch which is formed by first applying one and then the other.  The
composition of two patches, <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg4.png"
 ALT="$P_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg5.png"
 ALT="$P_2$"></SPAN> is represented as <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg6.png"
 ALT="$P_2P_1$"></SPAN>,
where <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg4.png"
 ALT="$P_1$"></SPAN> is to be applied first, then <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg5.png"
 ALT="$P_2$"></SPAN><A NAME="tex2html23"
  HREF="#foot1852"><SUP>A.<SPAN CLASS="arabic">3</SPAN></SUP></A>
<P>
There is one other very useful relationship that two patches can have,
which is to be parallel patches, which means that the two patches have an
identical context (i.e. their representation applies to identical trees).
This is represented by <!-- MATH
 $P_1\parallel P_2$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg7.png"
 ALT="$P_1\parallel P_2$"></SPAN>.  Of course, two patches may also
have no simple relationship to one another.  In that case, if you want to
do something with them, you'll have to manipulate them with respect to
other patches until they are either in sequence or in parallel.

<P>
The most fundamental and simple property of patches is that they must be
invertible.  The inverse of a patch is described by: <SPAN CLASS="MATH"><IMG
 WIDTH="34" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="bigimg8.png"
 ALT="$P^{ -1}$"></SPAN>.  In the
darcs implementation, the inverse is required to be computable from
knowledge of the patch only, without knowledge of its context, but that
(although convenient) is not required by the theory of patches.
<P>
<DIV><B>Definition  <SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>The inverse of patch <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="bigimg9.png"
 ALT="$P$"></SPAN> is <SPAN CLASS="MATH"><IMG
 WIDTH="34" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="bigimg8.png"
 ALT="$P^{ -1}$"></SPAN>, which is the ``simplest'' patch for
which the composition <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="bigimg10.png"
 ALT="\( P^{ -1} P \)"></SPAN> makes no changes to the tree.</I></DIV><P></P>
Using this definition, it is trivial to prove the following theorem
relating to the inverse of a composition of two patches.
<P>
<DIV><B>Theorem  <SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>The inverse of the composition of two patches is
</I>
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
(P_2 P_1)^{ -1} = P_1^{ -1} P_2^{ -1}.
\end{displaymath}
 -->

<IMG
 WIDTH="148" HEIGHT="28" BORDER="0"
 SRC="bigimg11.png"
 ALT="\begin{displaymath}(P_2 P_1)^{ -1} = P_1^{ -1} P_2^{ -1}. \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P></DIV><P></P>
Moreover, it is possible to show that the right inverse of a patch is equal
to its left inverse.  In this respect, patches continue to be analogous to
square matrices, and indeed the proofs relating to these properties of the
inverse are entirely analogous to the proofs in the case of matrix
multiplication.  The compositions proofs can also readily be extended to
the composition of more than two patches.

<P>

<H1><A NAME="SECTION00850000000000000000">
Commuting patches</A>
</H1>

<P>

<H2><A NAME="SECTION00851000000000000000">
Composite patches</A>
</H2>

<P>
Composite patches are made up of a series of patches intended to be applied
sequentially.  They are represented by a list of patches, with the first
patch in the list being applied first.

<P>

<P>
The first way (of only two) to change the context of a patch is by
commutation, which is the process of changing the order of two sequential
patches.
<P>
<DIV><B>Definition  <SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>The commutation of patches <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg4.png"
 ALT="$P_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg5.png"
 ALT="$P_2$"></SPAN> is represented by
</I>
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
P_2 P_1 \longleftrightarrow {P_1}' {P_2}'.
\end{displaymath}
 -->

<IMG
 WIDTH="121" HEIGHT="27" BORDER="0"
 SRC="bigimg12.png"
 ALT="\begin{displaymath}P_2 P_1 \longleftrightarrow {P_1}' {P_2}'. \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P><I>
Here <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg13.png"
 ALT="$P_1'$"></SPAN> is intended to describe the same change as <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg4.png"
 ALT="$P_1$"></SPAN>, with the
only difference being that <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg13.png"
 ALT="$P_1'$"></SPAN> is applied after <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg14.png"
 ALT="$P_2'$"></SPAN> rather than
before <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg5.png"
 ALT="$P_2$"></SPAN>.</I></DIV><P></P>
The above definition is obviously rather vague, the reason being that what
is the ``same change'' has not been defined, and we simply assume (and
hope) that the code's view of what is the ``same change'' will match those
of its human users.  The `<!-- MATH
 $\longleftrightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="bigimg15.png"
 ALT="$\longleftrightarrow $"></SPAN>' operator should be read as something
like the <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="12" ALIGN="BOTTOM" BORDER="0"
 SRC="bigimg16.png"
 ALT="$==$"></SPAN> operator in C, indicating that the right hand side performs
identical changes to the left hand side, but the two patches are in
reversed order.  When read in this manner, it is clear that commutation
must be a reversible process, and indeed this means that commutation
<SPAN  CLASS="textit">can</SPAN> fail, and must fail in certain cases.  For example, the creation
and deletion of the same file cannot be commuted.  When two patches fail to
commute, it is said that the second patch depends on the first, meaning
that it must have the first patch in its context (remembering that the
context of a patch is a set of patches, which is how we represent a tree).
<A NAME="tex2html24"
  HREF="#foot1874"><SUP>A.<SPAN CLASS="arabic">4</SPAN></SUP></A>
<P>

<H4><A NAME="SECTION00851010000000000000">
Merge</A>
</H4>
 
The second way one can change the context of a patch is by a <B>merge</B>
operation.  A merge is an operation that takes two parallel patches and
gives a pair of sequential patches.  The merge operation is represented by
the arrow ``<!-- MATH
 $\Longrightarrow$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="30" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="bigimg18.png"
 ALT="\( \Longrightarrow \)"></SPAN>''.
<P>
<DIV><A NAME="merge_dfn"><B>Definition  <SPAN CLASS="arabic">3</SPAN></B></A> &nbsp; 
<I>The result of a merge of two patches, <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg4.png"
 ALT="$P_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg5.png"
 ALT="$P_2$"></SPAN> is one of two patches,
<SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg13.png"
 ALT="$P_1'$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg14.png"
 ALT="$P_2'$"></SPAN>, which satisfy the relationship:
</I>
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
P_2 \parallel P_1 \Longrightarrow {P_2}' P_1 \longleftrightarrow {P_1}' P_2.
\end{displaymath}
 -->

<IMG
 WIDTH="206" HEIGHT="28" BORDER="0"
 SRC="bigimg19.png"
 ALT="\begin{displaymath}P_2 \parallel P_1 \Longrightarrow {P_2}' P_1 \longleftrightarrow {P_1}' P_2. \end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P></DIV><P></P>
Note that the sequential patches resulting from a merge are <SPAN  CLASS="textit">required</SPAN>
to commute.  This is an important consideration, as without it most of the
manipulations we would like to perform would not be possible.  The other
important fact is that a merge <SPAN  CLASS="textit">cannot fail</SPAN>.  Naively, those two
requirements seem contradictory.  In reality, what it means is that the
result of a merge may be a patch which is much more complex than any we
have yet considered<A NAME="tex2html25"
  HREF="#foot2009"><SUP>A.<SPAN CLASS="arabic">5</SPAN></SUP></A>.

<P>

<H2><A NAME="SECTION00852000000000000000">
How merges are actually performed</A>
</H2>

<P>
The constraint that any two compatible patches (patches which can
successfully be applied to the same tree) can be merged is actually quite
difficult to apply.  The above merge constraints also imply that the result
of a series of merges must be independent of the order of the merges.  So
I'm putting a whole section here for the interested to see what algorithms
I use to actually perform the merges (as this is pretty close to being the
most difficult part of the code).

<P>
The first case is that in which the two merges don't actually conflict, but
don't trivially merge either (e.g. hunk patches on the same file, where the
line number has to be shifted as they are merged).  This kind of merge can
actually be very elegantly dealt with using only commutation and inversion.

<P>
There is a handy little theorem which is immensely useful when trying to
merge two patches.
<P>
<DIV><A NAME="merge_thm"><B>Theorem  <SPAN CLASS="arabic">2</SPAN></B></A> &nbsp; 
<I><!-- MATH
 $P_2' P_1 \longleftrightarrow P_1' P_2$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="112" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg20.png"
 ALT="$ P_2' P_1 \longleftrightarrow P_1' P_2 $"></SPAN> if and only if <!-- MATH
 $P_1'^{ -1}
P_2' \longleftrightarrow P_2 P_1^{ -1}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="140" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg21.png"
 ALT="$ P_1'^{ -1}
P_2' \longleftrightarrow P_2 P_1^{ -1} $"></SPAN>, provided both commutations succeed.  If
either commute fails, this theorem does not apply.</I></DIV><P></P>
This can easily be proven by multiplying both sides of the first
commutation by <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg22.png"
 ALT="$P_1'^{ -1}$"></SPAN> on the left, and by <SPAN CLASS="MATH"><IMG
 WIDTH="34" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg23.png"
 ALT="$P_1^{ -1}$"></SPAN> on the right.
Besides being used in merging, this theorem is also useful in the recursive
commutations of mergers.  From Theorem&nbsp;<A HREF="#merge_thm"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>, we see that the
merge of <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg4.png"
 ALT="$P_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg14.png"
 ALT="$P_2'$"></SPAN> is simply the commutation of <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg5.png"
 ALT="$P_2$"></SPAN> with <SPAN CLASS="MATH"><IMG
 WIDTH="34" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg23.png"
 ALT="$P_1^{ -1}$"></SPAN> (making sure to do the commutation the right way).  Of course, if this
commutation fails, the patches conflict.  Moreover, one must check that the
merged result actually commutes with <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg4.png"
 ALT="$P_1$"></SPAN>, as the theorem applies only
when <SPAN  CLASS="textit">both</SPAN> commutations are successful.

<P>
Of course, there are patches that actually conflict, meaning a merge where
the two patches truly cannot both be applied (e.g. trying to create a file
and a directory with the same name).  We deal with this case by creating a
special kind of patch to support the merge, which we will call a
``merger''.  Basically, a merger is a patch that contains the two patches
that conflicted, and instructs darcs basically to resolve the conflict.  By
construction a merger will satisfy the commutation property (see
Definition&nbsp;<A HREF="#merge_dfn"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>) that characterizes all merges.  Moreover the
merger's properties are what makes the order of merges unimportant (which
is a rather critical property for darcs as a whole).

<P>
The job of a merger is basically to undo the two conflicting patches, and
then apply some sort of a ``resolution'' of the two instead.  In the case
of two conflicting hunks, this will look much like what CVS does, where it
inserts both versions into the file.  In general, of course, the two
conflicting patches may both be mergers themselves, in which case the
situation is considerably more complicated.

<P>
Much of the merger code depends on a routine which recreates from a single
merger the entire sequence of patches which led up to that merger (this is,
of course, assuming that this is the complicated general case of a merger
of mergers of mergers).  This ``unwind'' procedure is rather complicated,
but absolutely critical to the merger code, as without it we wouldn't even
be able to undo the effects of the patches involved in the merger, since we
wouldn't know what patches were all involved in it.

<P>
Basically, unwind takes a merger such as
<PRE>
M( M(A,B), M(A,M(C,D)))
</PRE>
From which it recreates a merge history:
<PRE>
C
A
M(A,B)
M( M(A,B), M(A,M(C,D)))
</PRE>
(For the curious, yes I can easily unwind this merger in my head [and on
paper can unwind insanely more complex mergers]--that's what comes of
working for a few months on an algorithm.)  Let's start with a simple
unwinding.  The merger <code>M(A,B)</code> simply means that two patches
(<code>A</code> and <code>B</code>) conflicted, and of the two of them <code>A</code> is
first in the history.  The last two patches in the unwinding of any merger
are always just this easy.  So this unwinds to:
<PRE>
A
M(A,B)
</PRE>
What about a merger of mergers? How about <code>M(A,M(C,D))</code>.  In this case
we know the two most recent patches are:
<PRE>
A
M(A,M(C,D))
</PRE>
But obviously the unwinding isn't complete, since we don't yet see where
<code>C</code> and <code>D</code> came from.  In this case we take the unwinding of
<code>M(C,D)</code> and drop its latest patch (which is <code>M(C,D)</code> itself) and
place that at the beginning of our patch train:
<PRE>
C
A
M(A,M(C,D))
</PRE>
As we look at <code>M( M(A,B), M(A,M(C,D)))</code>, we consider the unwindings of
each of its subpatches:
<PRE>
          C
A         A
M(A,B)    M(A,M(C,D))
</PRE>
As we did with <code>M(A,M(C,D))</code>, we'll drop the first patch on the
right and insert the first patch on the left.  That moves us up to the two
<code>A</code>'s.  Since these agree, we can use just one of them (they
``should'' agree).  That leaves us with the <code>C</code> which goes first.

<P>
The catch is that things don't always turn out this easily.  There is no
guarantee that the two <code>A</code>'s would come out at the same time, and if
they didn't, we'd have to rearrange things until they did.  Or if there was
no way to rearrange things so that they would agree, we have to go on to
plan B, which I will explain now.

<P>
Consider the case of <code>M( M(A,B), M(C,D))</code>.  We can easily unwind the
two subpatches
<PRE>
A         C
M(A,B)    M(C,D)
</PRE>
Now we need to reconcile the <code>A</code> and <code>C</code>.  How do we do this?
Well, as usual, the solution is to use the most wonderful
Theorem&nbsp;<A HREF="#merge_thm"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.  In this case we have to use it in the reverse of
how we used it when merging, since we know that <code>A</code> and <code>C</code> could
either one be the <SPAN  CLASS="textit">last</SPAN> patch applied before <code>M(A,B)</code> or
<code>M(C,D)</code>.  So we can find <code>C'</code> using
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
A^{ -1} C \longleftrightarrow C' A'^{ -1}
\end{displaymath}
 -->

<IMG
 WIDTH="127" HEIGHT="24" BORDER="0"
 SRC="bigimg24.png"
 ALT="\begin{displaymath}
A^{ -1} C \longleftrightarrow C' A'^{ -1}
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
Giving an unwinding of
<PRE>
C'
A
M(A,B)
M( M(A,B), M(C,D) )
</PRE>
There is a bit more complexity to the unwinding process (mostly having to
do with cases where you have deeper nesting), but I think the general
principles that are followed are pretty much included in the above
discussion.

<P>
It can sometimes be handy to have a canonical representation of a given
patch.  We achieve this by defining a canonical form for each patch type,
and a function ``<TT>canonize</TT>'' which takes a patch and puts it into
canonical form.  This routine is used by the diff function to create an
optimal patch (based on an LCS algorithm) from a simple hunk describing the
old and new version of a file.
Note that canonization may fail, if the patch is internally inconsistent.

<P>
A simpler, faster (and more generally useful) cousin of canonize is the
coalescing function.  This takes two sequential patches, and tries to turn
them into one patch.  This function is used to deal with ``split'' patches,
which are created when the commutation of a primitive patch can only be
represented by a composite patch.  In this case the resulting composite
patch must return to the original primitive patch when the commutation is
reversed, which a split patch accomplishes by trying to coalesce its
contents each time it is commuted.

<P>

<H2><A NAME="SECTION00853000000000000000">
File patches</A>
</H2>

<P>
A file patch is a patch which only modifies a single
file.  There are some rules which can be made about file patches in
general, which makes them a handy class.
For example, commutation of two filepatches is trivial if they modify
different files.  There is an exception when one of the files has a name
ending with ``-conflict'', in which case it may not commute with a file
having the same name, but without the ``-conflict.''  If they happen to
modify the same file, we'll have to check whether or not they commute.

<P>
There is another handy function, which primarily affects file patches
(although it can also affect other patches, such as rename patches or dir
add/remove patches), which is the submerge-in-directory function.  This
function changes the patch to act on a patch within a subdirectory rather
than in the current directory, and is useful when performing the recursive
diff.

<P>

<H2><A NAME="SECTION00854000000000000000">
Hunks</A>
</H2>

<P>
The hunk is the simplest patch that has a commuting pattern in which the
commuted patches differ from the originals (rather than simple success or
failure).  This makes commuting or merging two hunks a tad tedious.
Hunks, of course, can be coalesced if they have any overlap.  Note that
coalesce code doesn't check if the two patches are conflicting.  If you are
coalescing two conflicting hunks, you've already got a bug somewhere.

<P>
One of the most important pieces of code is the canonization of a hunk,
which is where the ``diff'' algorithm is performed.  This algorithm begins
with chopping off the identical beginnings and endings of the old and new
hunks.  This isn't strictly necessary, but is a good idea, since this
process is <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg25.png"
 ALT="$O(n)$"></SPAN>, while the primary diff algorithm is something
considerably more painful than that... actually the head would be dealt
with all right, but with more space complexity.  I think it's more
efficient to just chop the head and tail off first.

<P>

<H1><A NAME="SECTION00860000000000000000">
Conflicts</A>
</H1>

<P>
There are a couple of simple constraints on the routine which determines
how to resolve two conflicting patches (which is called `glump').  These
must be satisfied in order that the result of a series of merges is always
independent of their order.  Firstly, the output of glump cannot change
when the order of the two conflicting patches is switched.  If it did, then
commuting the merger could change the resulting patch, which would be bad.
Secondly, the result of the merge of three (or more) conflicting patches
cannot depend on the order in which the merges are performed.

<P>
The conflict resolution code (glump) begins by ``unravelling'' the merger
into a set of sequences of patches.  Each sequence of patches corresponds
to one non-conflicted patch that got merged together with the others.  The
result of the unravelling of a series of merges must obviously be
independent of the order in which those merges are performed.  This
unravelling code (which uses the unwind code mentioned above) uses probably
the second most complicated algorithm.  Fortunately, if we can successfully
unravel the merger, almost any function of the unravelled merger satisfies
the two constraints mentioned above that the conflict resolution code must
satisfy.

<P>

<H1><A NAME="SECTION00870000000000000000">
Patch string formatting</A>
</H1>

<P>
Of course, in order to store our patches in a file, we'll have to save them
as some sort of strings.  The convention is that each patch string will end
with a newline, but on parsing we skip any amount of whitespace between
patches.

<P>

<H4><A NAME="SECTION00870010000000000000">
Composite patch</A>
</H4>
A patch made up of a few other patches.
<PRE>
{
  &lt;put patches here&gt; (indented two)
}
</PRE>

<P>

<H4><A NAME="SECTION00870020000000000000">
Split patch</A>
</H4>
A split patch is similar to a composite patch (identical in how it's
stored), but rather than being composed of several patches grouped
together, it is created from one patch that has been split apart, typically
through a merge or commutation.
<PRE>
(
  &lt;put patches here&gt; (indented two)
)
</PRE>

<P>

<H4><A NAME="SECTION00870030000000000000">
Hunk</A>
</H4>
Replace a hunk (set of contiguous lines) of text with a new
hunk.
<PRE>
hunk FILE LINE#
-LINE
...
+LINE
...
</PRE>

<P>

<H4><A NAME="SECTION00870040000000000000">
Token replace</A>
</H4>

<P>
Replace a token with a new token.  Note that this format means that the
white space must not be allowed within a token.  If you know of a practical
application of whitespace within a token, let me know and I may change
this.
<PRE>
replace FILENAME [REGEX] OLD NEW
</PRE>

<P>

<H4><A NAME="SECTION00870050000000000000">
Binary file modification</A>
</H4>

<P>
Modify a binary file
<PRE>
binary FILENAME
oldhex
*HEXHEXHEX
...
newhex
*HEXHEXHEX
...
</PRE>

<P>

<H4><A NAME="SECTION00870060000000000000">
Add file</A>
</H4>
Add an empty file to the tree.

<P>
<code>addfile filename</code>

<P>

<H4><A NAME="SECTION00870070000000000000">
Remove file</A>
</H4>
Delete a file from the tree.

<P>
<code>rmfile filename</code>

<P>

<H4><A NAME="SECTION00870080000000000000">
Move</A>
</H4>
Rename a file or directory.

<P>
<code>move oldname newname</code>

<P>

<H4><A NAME="SECTION00870090000000000000">
Change Pref</A>
</H4>
Change one of the preference settings.  Darcs stores a number of simple
string settings.  Among these are the name of the test script and the name
of the script that must be called prior to packing in a make dist.
<PRE>
changepref prefname
oldval
newval
</PRE>

<P>

<H4><A NAME="SECTION008700100000000000000">
Add dir</A>
</H4>
Add an empty directory to the tree.

<P>
<code>adddir filename</code>

<P>

<H4><A NAME="SECTION008700110000000000000">
Remove dir</A>
</H4>
Delete a directory from the tree.

<P>
<code>rmdir filename</code>

<P>

<H4><A NAME="SECTION008700120000000000000">
Merger patches</A>
</H4>
Merge two patches.  The MERGERVERSION is included to allow some degree of
backwards compatibility if the merger algorithm needs to be changed.
<PRE>
merger MERGERVERSION
&lt;first patch&gt;
&lt;second patch&gt;
</PRE>

<P>

<H4><A NAME="SECTION008700130000000000000">
Conflictor patches</A>
</H4>
The conflictor patch type is the replacement for the old merger patch
type.  FIXME: More explanation should be added here.
<PRE>
conflict
&lt;CONFLICTING PATCH SEQUENCE&gt;
with
&lt;OLDER PATCH SEQUENCE&gt;
tcilfnoc
</PRE>

<P>

<H4><A NAME="SECTION008700140000000000000">
Named patches</A>
</H4>

<P>
Named patches are displayed as a ``patch id'' which is in square brackets,
followed by a patch.  Optionally, after the patch id (but before the patch
itself) can come a list of dependencies surrounded by angle brackets.  Each
dependency consists of a patch id.

<P>

<H1><A NAME="SECTION00900000000000000000"></A>
<A NAME="repository_format"></A>
<BR>
DarcsRepo format
</H1>

<P>
A repository consists of a working directory, which has within it a
directory called <code>_darcs</code>. There must also be subdirectories
within <code>_darcs</code> named <code>current</code> and <code>patches</code>. The
<code>current</code>  directory, called the <SPAN  CLASS="textit">pristine tree</SPAN>, contains
the version of the tree which has been recorded, while <code>patches</code>
contains the actual patches which are in the repository.

<P>
<SPAN  CLASS="textit">WARNING!</SPAN> Viewing files in current is perfectly acceptable, but if
you view them with an editor (e.g. vi or Emacs), that editor may create
temporary files in the pristine tree (<code>_darcs/pristine/</code> or
<code>_darcs/current/</code>), which will
temporarily cause your repository to be inconsistent.  So <SPAN  CLASS="textit">don't
record any patches while viewing files in _darcs/current with an editor!</SPAN>
A better plan would be to restrict yourself to viewing these files with a
pager such as more or less.

<P>
Also within <code>_darcs</code> is the <code>inventory</code> file, which lists all the
patches that are in the repo. Moreover, it also gives the order of the
representation of the patches as they are stored. Given a source of patches,
i.e. any other set of repositories which have between them all the patches
contained in a given repo, that repo can be reproduced based on only the
information in the <code>inventory</code> file. Under those circumstances, the
order of the patches specified in the <code>inventory</code> file would be
unimportant, as this order is only needed to provide context for the
interpretation of the stored patches in this repository.

<P>
There is a very special patch which may be stored in <code>patches</code> which
is called `pending'.  This patch describes any changes which have not yet
been recorded, and cannot be determined by a simple diff.  For example, file
additions or renames are placed in pending until they are recorded.
Similarly, token replaces are stored in pending until they are recorded.

<P>
The <code>_darcs</code> directory also contains a directory called
``<code>prefs</code>'', which is described in Chapter&nbsp;<A HREF="#configuring"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="./crossref.png"></A>.

<P>

<H1><A NAME="SECTION001000000000000000000"></A>
<A NAME="gpl"></A>
<BR>
The GNU General Public License
</H1>

<H1><A NAME="SECTION001010000000000000000">
Version 2, June 1991</A>
</H1>

<P>
<DIV ALIGN="CENTER">
Version 2, June 1991
</DIV>
<P>
<DIV ALIGN="CENTER">Copyright &#169; 1989, 1991 Free Software Foundation, Inc.
</DIV>
<P>
<DIV ALIGN="CENTER"></DIV>
<P><P>
<BR>
<DIV ALIGN="CENTER"></DIV>
<P>
<DIV ALIGN="CENTER">59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
</DIV>
<P>
<DIV ALIGN="CENTER"></DIV>
<P><P>
<BR>
<DIV ALIGN="CENTER"></DIV>
<P>
<DIV ALIGN="CENTER">Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</DIV>
<P>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H1><A NAME="SECTION001020000000000000000">
Preamble</A>
</H1>
<BLOCKQUOTE>
The licenses for most software are designed to take away your freedom to
share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free software--to
make sure the software is free for all its users.  This General Public
License applies to most of the Free Software Foundation's software and to
any other program whose authors commit to using it.  (Some other Free
Software Foundation software is covered by the GNU Library General Public
License instead.)  You can apply it to your programs, too.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>When we speak of free software, we are referring to freedom, not price.
Our General Public Licenses are designed to make sure that you have the
freedom to distribute copies of free software (and charge for this service
if you wish), that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free programs;
and that you know you can do these things.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>To protect your rights, we need to make restrictions that forbid anyone to
deny you these rights or to ask you to surrender the rights.  These
restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>For example, if you distribute copies of such a program, whether gratis or
for a fee, you must give the recipients all the rights that you have.  You
must make sure that they, too, receive or can get the source code.  And
you must show them these terms so they know their rights.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>We protect your rights with two steps: (1) copyright the software, and (2)
offer you this license which gives you legal permission to copy,
distribute and/or modify the software.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Also, for each author's protection and ours, we want to make certain that
everyone understands that there is no warranty for this free software.  If
the software is modified by someone else and passed on, we want its
recipients to know that what they have is not the original, so that any
problems introduced by others will not reflect on the original authors'
reputations.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>Finally, any free program is threatened constantly by software patents.
We wish to avoid the danger that redistributors of a free program will
individually obtain patent licenses, in effect making the program
proprietary.  To prevent this, we have made it clear that any patent must
be licensed for everyone's free use or not licensed at all.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>The precise terms and conditions for copying, distribution and
modification follow.

</BLOCKQUOTE>

<P>
<DIV ALIGN="CENTER">
<BIG CLASS="XLARGE">GNU G<SMALL>ENERAL </SMALL>P<SMALL>UBLIC </SMALL>L<SMALL>ICENSE

<BR></SMALL>
<BR>
T<SMALL>ERMS AND </SMALL>C<SMALL>ONDITIONS </SMALL>F<SMALL>OR </SMALL>C<SMALL>OPYING, </SMALL>D<SMALL>ISTRIBUTION AND </SMALL>M<SMALL>ODIFICATION</SMALL></BIG>

</DIV>

<P>

<OL>
<LI><P>
This License applies to any program or other work which contains a notice
placed by the copyright holder saying it may be distributed under the
terms of this General Public License.  The ``Program'', below, refers to
any such program or work, and a ``work based on the Program'' means either
the Program or any derivative work under copyright law: that is to say, a
work containing the Program or a portion of it, either verbatim or with
modifications and/or translated into another language.  (Hereinafter,
translation is included without limitation in the term ``modification''.)
Each licensee is addressed as ``you''.

<P>
Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

<P>
</LI>
<LI>You may copy and distribute verbatim copies of the Program's source
  code as you receive it, in any medium, provided that you conspicuously
  and appropriately publish on each copy an appropriate copyright notice
  and disclaimer of warranty; keep intact all the notices that refer to
  this License and to the absence of any warranty; and give any other
  recipients of the Program a copy of this License along with the Program.

<P>
You may charge a fee for the physical act of transferring a copy, and you
may at your option offer warranty protection in exchange for a fee.

<P>
</LI>
<LI><P>
You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

<P>

<OL>
<LI><P>
You must cause the modified files to carry prominent notices stating that
you changed the files and the date of any change.

<P>
</LI>
<LI><P>
You must cause any work that you distribute or publish, that in
whole or in part contains or is derived from the Program or any
part thereof, to be licensed as a whole at no charge to all third
parties under the terms of this License.

<P>
</LI>
<LI>If the modified program normally reads commands interactively
when run, you must cause it, when started running for such
interactive use in the most ordinary way, to print or display an
announcement including an appropriate copyright notice and a
notice that there is no warranty (or else, saying that you provide
a warranty) and that users may redistribute the program under
these conditions, and telling the user how to view a copy of this
License.  (Exception: if the Program itself is interactive but
does not normally print such an announcement, your work based on
the Program is not required to print an announcement.)

<P>
</LI>
</OL>

<P>
These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

<P>
Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

<P>
In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

<P>
</LI>
<LI>You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

<P>

<OL>
<LI><P>
Accompany it with the complete corresponding machine-readable
source code, which must be distributed under the terms of Sections
1 and 2 above on a medium customarily used for software interchange; or,

<P>
</LI>
<LI><P>
Accompany it with a written offer, valid for at least three
years, to give any third party, for a charge no more than your
cost of physically performing source distribution, a complete
machine-readable copy of the corresponding source code, to be
distributed under the terms of Sections 1 and 2 above on a medium
customarily used for software interchange; or,

<P>
</LI>
<LI><P>
Accompany it with the information you received as to the offer
to distribute corresponding source code.  (This alternative is
allowed only for noncommercial distribution and only if you
received the program in object code or executable form with such
an offer, in accord with Subsection b above.)

<P>
</LI>
</OL>

<P>
The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

<P>
If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

<P>
</LI>
<LI>You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

<P>
</LI>
<LI>You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

<P>
</LI>
<LI>Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

<P>
</LI>
<LI>If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

<P>
If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

<P>
It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

<P>
This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

<P>
</LI>
<LI>If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

<P>
</LI>
<LI>The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

<P>
Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and ``any
later version'', you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

<P>
</LI>
<LI>If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

<P>
<DIV ALIGN="CENTER">
<BIG CLASS="XLARGE">
N<SMALL>O </SMALL>W<SMALL>ARRANTY
</SMALL></BIG>

</DIV>

<P>
</LI>
<LI>B<SMALL>ECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  </SMALL>E<SMALL>XCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM ``AS IS'' WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  </SMALL>T<SMALL>HE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  </SMALL>S<SMALL>HOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.</SMALL>

<P>
</LI>
<LI>I<SMALL>N NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.</SMALL>

<P>
</LI>
</OL>

<P>
<DIV ALIGN="CENTER">
<BIG CLASS="XLARGE">E<SMALL>ND OF </SMALL>T<SMALL>ERMS AND </SMALL>C<SMALL>ONDITIONS</SMALL></BIG>

</DIV>

<P>

<H1><A NAME="SECTION001030000000000000000">
Appendix: How to Apply These Terms to Your New Programs</A>
</H1>

<P>
If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

<P>
To do so, attach the following notices to the program.  It is safest to
  attach them to the start of each source file to most effectively convey
  the exclusion of warranty; and each file should have at least the
  ``copyright'' line and a pointer to where the full notice is found.

<P>
<BLOCKQUOTE>
<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg1.png"
 ALT="$&lt;$"></SPAN>one line to give the program's name and a brief idea of what it does.<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg2.png"
 ALT="$&gt;$"></SPAN> 
<BR>
Copyright (C) <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg1.png"
 ALT="$&lt;$"></SPAN>year<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg2.png"
 ALT="$&gt;$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg1.png"
 ALT="$&lt;$"></SPAN>name of author<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg2.png"
 ALT="$&gt;$"></SPAN> 
<BR></BLOCKQUOTE>
<P>
<BLOCKQUOTE>This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

</BLOCKQUOTE>

<P>
Also add information on how to contact you by electronic and paper mail.

<P>
If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

<P>
<BLOCKQUOTE>
Gnomovision version 69, Copyright (C) <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg1.png"
 ALT="$&lt;$"></SPAN>year<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg2.png"
 ALT="$&gt;$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg1.png"
 ALT="$&lt;$"></SPAN>name of author<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg2.png"
 ALT="$&gt;$"></SPAN> 
<BR>
Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. 
<BR>
This is free software, and you are welcome to redistribute it
under certain conditions; type `show c' for details.

</BLOCKQUOTE>

<P>
The hypothetical commands <TT>show w</TT> and <TT>show c</TT> should show the
appropriate parts of the General Public License.  Of course, the commands
you use may be called something other than <TT>show w</TT> and <TT>show c</TT>;
they could even be mouse-clicks or menu items--whatever suits your
program.

<P>
You should also get your employer (if you work as a programmer) or your
school, if any, to sign a ``copyright disclaimer'' for the program, if
necessary.  Here is a sample; alter the names:

<P>
<BLOCKQUOTE>
Yoyodyne, Inc., hereby disclaims all copyright interest in the program 
<BR>`Gnomovision' (which makes passes at compilers) written by James Hacker. 
<BR></BLOCKQUOTE>
<P>
<BLOCKQUOTE><SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg1.png"
 ALT="$&lt;$"></SPAN>signature of Ty Coon<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="28" ALIGN="MIDDLE" BORDER="0"
 SRC="bigimg2.png"
 ALT="$&gt;$"></SPAN>, 1 April 1989 
<BR>
Ty Coon, President of Vice

</BLOCKQUOTE>

<P>
This General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications
with the library.  If this is what you want to do, use the GNU Library
General Public License instead of this License.

<P>

<H1><A NAME="SECTION001100000000000000000">
About this document ...</A>
</H1>
 <STRONG>
    Darcs 1.0.6pre1 (unknown)
<BR><BIG CLASS="XLARGE"><I>Darcs</I></BIG>
</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2002-2-1 (1.70)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-white -split 0 -external_file darcs -prefix big -no_auto_link -dir manual bigpage.tex</TT>
<P>
The translation was initiated by Tommy Pettersson on 2005-12-14
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot199">...</A><A
 HREF="bigpage.html#tex2html8"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>Note that darcs does not do wildcard expansion, instead relying
on the command shell.  The Windows port of darcs has a limited form of
expansion provided by the C runtime

</DD>
<DT><A NAME="foot2000">...<EM>patch</EM>).</A><A
 HREF="bigpage.html#tex2html9"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>If
	you look inside _darcs you will find files or directories named
	<TT>patches</TT> and <TT>inventories</TT>, which store all the patches
          ever recorded.  If the repository holds a cached pristine tree, it
          is stored in a directory called <TT>pristine</TT> or <TT>current</TT>;
          otherwise, the fact that there is no pristine tree is marked
          by the presence of a file called <TT>pristine.none</TT> or <TT>current.none</TT>.

</DD>
<DT><A NAME="foot369">...</A><A
 HREF="bigpage.html#tex2html10"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A></DT>
<DD>Revert can undo precious work in a blink.
		To protect you from great grief,
		the discarded changes are saved temporarily
		so the latest revert can be undone with unrevert.

</DD>
<DT><A NAME="foot2001">...pending</A><A
 HREF="bigpage.html#tex2html11"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN></SUP></A></DT>
<DD>In the file <TT>_darcs/patches/pending</TT>.

</DD>
<DT><A NAME="foot420">... code.</A><A
 HREF="bigpage.html#tex2html12"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN></SUP></A></DT>
<DD>Actually it doesn't have to--in theory--,
but in practice it's hard to create ``negative'' files or lines in the working tree.
See the chapter about Theory of patches for other constraints.

</DD>
<DT><A NAME="foot2002">... it.</A><A
 HREF="bigpage.html#tex2html13"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN></SUP></A></DT>
<DD>darcs even has a special command, <TT>trackdown</TT>
that automatically removes patches
until a specified test no longer fails.

</DD>
<DT><A NAME="foot429">... repository.</A><A
 HREF="bigpage.html#tex2html14"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN></SUP></A></DT>
<DD>It will omit patches already depended upon by other patches,
since they will be indirectly depended upon anyway.

</DD>
<DT><A NAME="foot436">... parts</A><A
 HREF="bigpage.html#tex2html15"><SUP><SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN></SUP></A></DT>
<DD>The primitive patches making up the total patch.

</DD>
<DT><A NAME="foot461">...
push</A><A
 HREF="bigpage.html#tex2html16"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>But it affects the repository and working directory targeted by
the push

</DD>
<DT><A NAME="foot462">...
send</A><A
 HREF="bigpage.html#tex2html17"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A></DT>
<DD>As for the other end, see apply

</DD>
<DT><A NAME="foot463">...
put</A><A
 HREF="bigpage.html#tex2html18"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN></SUP></A></DT>
<DD>Creates a new repository

</DD>
<DT><A NAME="foot1106">...
input.</A><A
 HREF="bigpage.html#tex2html19"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN></SUP></A></DT>
<DD>One caveat: don't name your patch file ``magic darcs
standard input'', or darcs will read from standard input instead!

</DD>
<DT><A NAME="foot1492">... back.</A><A
 HREF="bigpage.html#tex2html20"><SUP><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN></SUP></A></DT>
<DD>The patch file itself is not actually deleted, but its
context is lost, so it cannot be reliably read--your only choice would be
to go in by hand and read its contents.

</DD>
<DT><A NAME="foot2008">... representation</A><A
 HREF="bigpage.html#tex2html21"><SUP>A.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>For those comfortable with
quantum mechanics, think of a patch as a quantum mechanical operator, and
the representation as the basis set.  The analogy breaks down pretty
quickly, however, since an operator could be described in any complete
basis set, while a patch modifying the file <TT>foo</TT> can only be described
in the rather small set of contexts which have a file <TT>foo</TT> to be
modified.

</DD>
<DT><A NAME="foot1842">... tree</A><A
 HREF="bigpage.html#tex2html22"><SUP>A.<SPAN CLASS="arabic">2</SPAN></SUP></A></DT>
<DD>This is very similar to the second-quantized picture,
in which any state is seen as the result of a number of creation operators
acting on the vacuum, and provides a similar set of simplifications--in
particular, the exclusion principle is very elegantly enforced by the
properties of the anti-hermitian fermion creation operators.

</DD>
<DT><A NAME="foot1852">...#tex2html_wrap_inline2056#</A><A
 HREF="bigpage.html#tex2html23"><SUP>A.<SPAN CLASS="arabic">3</SPAN></SUP></A></DT>
<DD>This notation is
inspired by the notation of matrix multiplication or the application of
operators upon a Hilbert space.  In the algebra of patches, there is
multiplication (i.e. composition), which is associative but not
commutative, but no addition or subtraction.

</DD>
<DT><A NAME="foot1874">... tree).</A><A
 HREF="bigpage.html#tex2html24"><SUP>A.<SPAN CLASS="arabic">4</SPAN></SUP></A></DT>
<DD>The fact that commutation can fail makes a huge difference in the
whole patch formalism.  It may be possible to create a formalism in which
commutation always succeeds, with the result of what would otherwise be a
commutation that fails being something like a virtual particle (which can
violate conservation of energy), and it may be that such a formalism would
allow strict mathematical proofs (whereas those used in the current
formalism are mostly only hand waving ``physicist'' proofs).  However, I'm
not sure how you'd deal with a request to delete a file that has not yet
been created, for example.  Obviously you'd need to create some kind of
antifile, which would annihilate with the file when that file finally got
created, but I'm not entirely sure how I'd go about doing this.
<SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="bigimg17.png"
 ALT="$\ddot\frown$"></SPAN> So I'm sticking with my hand waving formalism.

</DD>
<DT><A NAME="foot2009">... considered</A><A
 HREF="bigpage.html#tex2html25"><SUP>A.<SPAN CLASS="arabic">5</SPAN></SUP></A></DT>
<DD>Alas, I don't know how to prove that the two
constraints even <SPAN  CLASS="textit">can</SPAN> be satisfied.  The best I have been able to do
is to believe that they can be satisfied, and to be unable to find an case
in which my implementation fails to satisfy them.  These two requirements
are the foundation of the entire theory of patches (have you been counting
how many foundations it has?).

</DD>
</DL>
<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="22" HEIGHT="22" title="Next"  ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="./nx_grp_g.png"> 
<IMG WIDTH="22" HEIGHT="22" title="Up"  ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./up_g.png"> 
<IMG WIDTH="22" HEIGHT="22" title="Previous"  ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./prev_g.png">   
<BR></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
Tommy Pettersson
2005-12-14
</ADDRESS>
</BODY>
</HTML>
